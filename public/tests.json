{
  "tests": [
    {
      "id": "Software Architecture",
      "name": "Software Architecture Final Test",
      "description": "A comprehensive test covering key concepts in software architecture, including quality attributes, architectural patterns, and design principles.",
      "questions": [
        {
          "question": "In architectural partitioning, what is the primary criterion for determining how to 'sensibly' divide an application into components?",
          "options": [
            "The personal preferences of the development team",
            "Meeting specific application requirements and constraints",
            "Following the latest industry trends regardless of context",
            "Maximizing the number of components for better granularity"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural partitioning must be driven by the specific requirements and constraints of the application itself, not by trends or preferences. Different applications with different requirements will have different sensible partitions."
        },
        {
          "question": "Which statement best describes the relationship between quality attributes and system architecture?",
          "options": [
            "Quality attributes are secondary concerns that can be addressed after functional requirements are implemented",
            "Architecture exists primarily to satisfy quality attributes, not just functional requirements",
            "Quality attributes only affect the user interface layer of the system",
            "Each quality attribute can be maximized independently without affecting others"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architecture fundamentally exists to satisfy quality attributes (performance, security, maintainability, etc.). Functional requirements define what the system does, but quality attributes define how well it does it and directly shape architectural decisions."
        },
        {
          "question": "What is the key difference between non-functional requirements and quality attributes?",
          "options": [
            "Non-functional requirements are technical while quality attributes are business-oriented",
            "Non-functional requirements are vague statements while quality attributes are measurable characteristics",
            "They are synonymous terms for the same concept",
            "Non-functional requirements apply to the development process while quality attributes apply to the final product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Non-functional requirements are often stated informally (e.g., 'system must be fast'), while quality attributes turn these into measurable, actionable characteristics (e.g., 'response time under 2 seconds') that can drive architectural decisions."
        },
        {
          "question": "Which architectural tactic would MOST directly address reliability concerns?",
          "options": [
            "Implementing a comprehensive logging framework",
            "Adding redundancy and failover mechanisms",
            "Using the latest programming language features",
            "Creating detailed documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Reliability focuses on correct performance over time, availability, and fault tolerance. Redundancy and failover mechanisms directly address these by ensuring continued operation even when components fail."
        },
        {
          "question": "What is the fundamental purpose of creating multiple architectural models for the same system?",
          "options": [
            "To increase documentation workload for developers",
            "To satisfy different stakeholder concerns and viewpoints",
            "To demonstrate the architect's versatility in modeling techniques",
            "To provide backup options if one model proves incorrect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Different stakeholders (business users, developers, operations) have different concerns. No single model can address all viewpoints effectively, so multiple models following the principle of separation of concerns are necessary."
        },
        {
          "question": "In the context of ISO/IEC 25010, which quality characteristic would be MOST compromised by choosing a monolithic architecture over microservices?",
          "options": [
            "Functional Suitability",
            "Performance Efficiency",
            "Scalability and Maintainability",
            "Security"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "While monolithic architectures can have advantages, microservices typically offer better scalability (part of Performance Efficiency) and maintainability due to independent deployability and clearer component boundaries."
        },
        {
          "question": "Which element should NEVER appear in a Context Diagram?",
          "options": [
            "External user roles",
            "Interaction flows with external systems",
            "Internal service components",
            "System boundary definition"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "A Context Diagram shows the system as a single black box interacting with its external environment. Showing internal components violates its purpose and turns it into a different type of diagram."
        },
        {
          "question": "What is the primary risk of NOT documenting architectural design decisions?",
          "options": [
            "Increased initial development cost",
            "Loss of rationale and context for future maintainers",
            "Immediate system failure",
            "Violation of coding standards"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions represent trade-offs made based on specific constraints and requirements. Without documenting the rationale (why certain options were chosen over others), future maintainers may misunderstand the architecture or make changes that violate original assumptions."
        },
        {
          "question": "Which quality attribute trade-off is most commonly encountered when implementing extensive caching strategies?",
          "options": [
            "Security vs Usability",
            "Performance vs Data Consistency",
            "Portability vs Functionality",
            "Reliability vs Cost"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Caching improves performance (response time, throughput) but introduces complexity around cache invalidation and data consistency, potentially leading to stale data being served."
        },
        {
          "question": "What distinguishes a Domain Model from a Design Model?",
          "options": [
            "Domain Models use UML while Design Models use pseudocode",
            "Domain Models describe business concepts while Design Models describe technical implementation",
            "Domain Models are created by developers while Design Models are created by business analysts",
            "Domain Models focus on performance while Design Models focus on functionality"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A Domain Model captures business concepts, relationships, and rules in business language, independent of technology. A Design Model translates these into technical components, services, and implementation structures."
        },
        {
          "question": "Why is it particularly challenging to validate architectural decisions early in a project lifecycle?",
          "options": [
            "Stakeholders are unavailable for consultation early on",
            "Many decisions cannot be fully tested until parts of the system are built",
            "Architects lack sufficient information to make any decisions early on",
            "Early validation requires complete system specification"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions involve system-wide concerns that often depend on interactions between components. These interactions and their consequences may only become apparent when significant portions of the system are implemented and integrated."
        },
        {
          "question": "Which of the following is a key benefit of using architectural patterns?",
          "options": [
            "They eliminate the need for custom design work",
            "They provide proven solutions with known engineering trade-offs",
            "They guarantee optimal performance for any application",
            "They automatically generate implementation code"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural patterns encode proven solutions to common problems, along with their known benefits and trade-offs. This allows architects to leverage collective experience rather than inventing solutions from scratch."
        },
        {
          "question": "What role does a 'marketeecture' play in the architectural process?",
          "options": [
            "It serves as the final technical specification for developers",
            "It facilitates stakeholder communication and high-level understanding",
            "It replaces the need for detailed architectural documentation",
            "It provides performance benchmarks for the system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A marketeecture is a simplified, high-level visualization that helps non-technical stakeholders understand the system's value proposition and basic structure, facilitating discussion and alignment."
        },
        {
          "question": "Which quality attribute would be MOST directly improved by implementing an API-first design approach?",
          "options": [
            "Reliability",
            "Compatibility",
            "Security",
            "Portability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "API-first design, with stable contracts and versioning strategies, directly improves compatibility by ensuring clear, consistent interfaces for system interaction and data exchange."
        },
        {
          "question": "What is the primary purpose of hierarchical decomposition in architectural description?",
          "options": [
            "To hide complexity by revealing details only at appropriate abstraction levels",
            "To create more documentation than necessary",
            "To demonstrate all possible implementation paths",
            "To eliminate the need for multiple architectural views"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Hierarchical decomposition allows architects to manage complexity by presenting the architecture at different levels of detail. High-level views show major components and relationships, while lower levels reveal internal structures only when necessary."
        },
        {
          "question": "Which architectural view would be MOST useful for infrastructure teams planning server deployment?",
          "options": [
            "Logical View",
            "Process View",
            "Physical View",
            "Development View"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "The Physical View shows how software components are mapped to hardware resources, which is essential for infrastructure teams responsible for deployment, scaling, and hardware provisioning."
        },
        {
          "question": "What distinguishes responsibility-driven design from other component identification approaches?",
          "options": [
            "It focuses on assigning specific tasks and behaviors to components",
            "It prioritizes minimizing the number of components above all else",
            "It requires components to be implemented in object-oriented languages only",
            "It emphasizes data structures over component behavior"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Responsibility-driven design focuses on what each component should be responsible for—what tasks it performs and what behaviors it exhibits—which helps create cohesive, well-defined components with clear purposes."
        },
        {
          "question": "Which statement BEST describes the relationship between functional requirements and quality attributes?",
          "options": [
            "Functional requirements are more important than quality attributes",
            "Quality attributes constrain how functional requirements are implemented",
            "They are independent concerns that can be addressed separately",
            "Quality attributes are only relevant after functional requirements are satisfied"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Quality attributes (performance, security, etc.) dictate constraints on how functional requirements are implemented. For example, a 'place order' function must be implemented securely, performantly, and reliably."
        },
        {
          "question": "What is the primary value of creating an Informational Model separate from a Domain Model?",
          "options": [
            "It focuses purely on data structures independently of business meaning",
            "It serves as a technical database schema for implementation",
            "It replaces the need for database administrators",
            "It ensures all business rules are encoded in the data layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "An Informational Model focuses on the structure, relationships, and integrity of data itself, separate from the business semantics captured in the Domain Model. This separation allows clearer thinking about data design."
        },
        {
          "question": "Which architectural decision would MOST significantly impact system portability?",
          "options": [
            "Choosing a specific cloud provider's proprietary services",
            "Implementing comprehensive error logging",
            "Using design patterns in the codebase",
            "Creating detailed API documentation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Portability refers to the ease of moving the system between environments. Vendor lock-in through proprietary services severely reduces portability, while containerization and abstraction layers enhance it."
        },
        {
          "question": "What is the fundamental purpose of architectural validation?",
          "options": [
            "To ensure the architecture will satisfy quality attributes before major implementation",
            "To eliminate all risks from the development process",
            "To create perfect documentation for all stakeholders",
            "To guarantee the project will be delivered on time"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Architectural validation techniques (prototyping, analysis, simulation) aim to verify that the chosen architecture will meet critical quality requirements before substantial resources are committed to implementation."
        },
        {
          "question": "Which quality attribute is MOST directly addressed by implementing authentication, authorization, and encryption?",
          "options": [
            "Reliability",
            "Security",
            "Usability",
            "Maintainability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "These are core security mechanisms that address confidentiality (encryption), authenticity (authentication), and authorization (access control)—all sub-characteristics of Security in ISO 25010."
        },
        {
          "question": "What is the key insight behind using metrics for quality attributes?",
          "options": [
            "Metrics make abstract quality attributes measurable and comparable",
            "Metrics eliminate the need for architectural expertise",
            "All quality attributes can be reduced to a single metric",
            "Metrics are only useful for performance-related attributes"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Metrics transform vague quality goals (e.g., 'good performance') into measurable targets (e.g., '95th percentile response time < 200ms'), enabling objective evaluation, comparison, and trade-off analysis."
        },
        {
          "question": "Which scenario BEST illustrates a business constraint (as opposed to a technical constraint)?",
          "options": [
            "The application must use Java because the team only has Java expertise",
            "The database must run on Linux for security reasons",
            "The system must integrate with a specific partner's API to access their customer base",
            "The server must have at least 16GB RAM for adequate performance"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Business constraints arise from commercial, strategic, or operational business decisions rather than technical limitations. Integration for market access is a business-driven constraint."
        },
        {
          "question": "What is the primary danger of treating quality attributes as afterthoughts in architecture?",
          "options": [
            "They can become impossible or extremely costly to add later",
            "They only affect non-critical parts of the system",
            "They are easily retrofitted into any existing architecture",
            "They primarily impact only the user interface layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes like scalability, security, and maintainability often require fundamental architectural decisions. Retrofitting them later can require major rework, if it's possible at all."
        },
        {
          "question": "Which architectural style would be MOST appropriate for a system requiring independent scalability of different functional areas?",
          "options": [
            "Monolithic Architecture",
            "Layered Architecture",
            "Microservices Architecture",
            "Client-Server Architecture"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Microservices allow individual services to be scaled independently based on their specific load requirements, unlike monolithic architectures where the entire application scales together."
        },
        {
          "question": "What is the key characteristic of the Process View in architectural modeling?",
          "options": [
            "It focuses on concurrency, communication, and runtime behavior",
            "It shows the mapping of software to hardware resources",
            "It describes the static structure using class-like elements",
            "It organizes code in development environments"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Process View addresses runtime concerns: how components execute (threads, processes), how they communicate (synchronously/asynchronously), and how they handle concurrency."
        },
        {
          "question": "Which practice would MOST improve system maintainability?",
          "options": [
            "Implementing tight coupling between components for simplicity",
            "Creating clear component boundaries with low coupling and high cohesion",
            "Using the fewest possible components regardless of responsibility",
            "Writing all code in a single programming language"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Maintainability depends on how easily the system can be modified. Clear boundaries with low coupling (minimal dependencies) and high cohesion (related functionality together) make changes more localized and predictable."
        },
        {
          "question": "What is the fundamental purpose of stakeholder requirements analysis?",
          "options": [
            "To create technical specifications for developers",
            "To align development with business goals and user needs before building",
            "To eliminate all communication with non-technical stakeholders",
            "To produce marketing materials for the product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stakeholder requirements capture the needs, expectations, and constraints of all parties involved. This alignment ensures the resulting system delivers real value and meets actual needs."
        },
        {
          "question": "Which architectural consideration is MOST critical when designing for high availability?",
          "options": [
            "Minimizing the number of external dependencies",
            "Eliminating all single points of failure",
            "Using the fastest available hardware",
            "Implementing the most sophisticated algorithms"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "High availability requires that no single component failure can bring down the entire system. This typically involves redundancy, failover mechanisms, and distributed architectures."
        },
        {
          "question": "What distinguishes explicit requirements from implicit requirements?",
          "options": [
            "Explicit requirements are documented while implicit ones are assumed",
            "Explicit requirements are technical while implicit ones are business-related",
            "Explicit requirements change frequently while implicit ones are stable",
            "Explicit requirements are optional while implicit ones are mandatory"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Explicit requirements are formally stated and documented. Implicit requirements are unstated assumptions or expectations that stakeholders believe are obvious but may not be captured formally, leading to potential misunderstandings."
        },
        {
          "question": "Which factor MOST influences the choice between synchronous and asynchronous communication between components?",
          "options": [
            "The programming language used for implementation",
            "Performance requirements and coupling tolerance",
            "The preferences of the development team",
            "The cost of development tools"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Synchronous communication (tight coupling, simpler) vs asynchronous (looser coupling, more complex) involves trade-offs between performance, reliability, and system complexity that must align with quality requirements."
        },
        {
          "question": "What is the primary purpose of architectural prototyping?",
          "options": [
            "To create a fully functional version of the system",
            "To validate technical risks and architectural hypotheses",
            "To replace the need for requirements analysis",
            "To serve as the final production system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural prototypes focus on validating specific high-risk aspects of the architecture (performance, integration, etc.) rather than building complete functionality."
        },
        {
          "question": "Which quality attribute would be MOST affected by implementing a Backend-for-Frontend (BFF) pattern?",
          "options": ["Security", "Usability", "Portability", "Reliability"],
          "correctOption": 1,
          "points": 10,
          "explanation": "BFF creates separate backend services tailored to specific frontend needs, improving usability by optimizing data delivery and interactions for each user interface context."
        },
        {
          "question": "What is the key benefit of using Commercial Off-The-Shelf (COTS) technologies that implement architectural patterns?",
          "options": [
            "They eliminate all customization needs",
            "They provide proven implementations of architectural approaches",
            "They guarantee the best performance for any use case",
            "They reduce the need for architectural design altogether"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "COTS technologies (like message brokers, application servers) provide ready-made, tested implementations of common architectural patterns, reducing development risk and effort."
        },
        {
          "question": "Which practice would MOST improve system analysability (ease of understanding the system)?",
          "options": [
            "Using short, cryptic variable names to save space",
            "Creating complex, deeply nested component hierarchies",
            "Implementing clear module decomposition with meaningful names",
            "Minimizing documentation to avoid outdated information"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Analysability, a sub-characteristic of Maintainability, is improved by clear organization, meaningful naming, and logical decomposition that helps developers understand system structure and behavior."
        },
        {
          "question": "What is the fundamental challenge in balancing security and usability?",
          "options": [
            "They are mutually exclusive and cannot coexist",
            "Increased security measures often create user friction",
            "Usability always compromises security effectiveness",
            "Security is only relevant for administrative users"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Strong security (multi-factor authentication, frequent re-authentication, complex passwords) can hinder usability. Architects must find balanced solutions that provide adequate security without excessive user burden."
        },
        {
          "question": "Which architectural decision would MOST directly address scalability concerns?",
          "options": [
            "Implementing comprehensive audit logging",
            "Using stateless services with horizontal scaling",
            "Choosing a specific programming language",
            "Creating detailed user documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stateless services can be easily replicated across multiple servers (horizontal scaling), allowing the system to handle increased load by adding more instances rather than upgrading single servers."
        },
        {
          "question": "What is the primary value of the ISO/IEC 25010 quality model?",
          "options": [
            "It provides a complete checklist of all possible system features",
            "It offers a standardized vocabulary for discussing system quality",
            "It eliminates the need for architectural decision-making",
            "It guarantees specific performance levels for any system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ISO 25010 provides a shared, standardized framework for discussing, specifying, and evaluating software quality characteristics, enabling clearer communication between stakeholders."
        },
        {
          "question": "Which factor is MOST critical when evaluating architectural alternatives?",
          "options": [
            "The popularity of each alternative in the industry",
            "How well each addresses the specific quality attribute priorities",
            "The complexity of implementation for each alternative",
            "The personal preferences of the architect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions should be driven by how well alternatives satisfy the prioritized quality attributes for the specific system context, not by general popularity or personal preference."
        },
        {
          "question": "What is the key insight about system failures according to the quality attributes lecture?",
          "options": [
            "Most failures are caused by missing features rather than quality issues",
            "Quality issues cause more system failures than missing functionality",
            "Failures are evenly distributed between functional and quality issues",
            "Failures are primarily caused by hardware rather than software issues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "The lecture emphasizes that systems with identical features can have very different success based on quality attributes, and that quality issues (performance, reliability, security) often cause more problems than missing features."
        },
        {
          "question": "Which architectural approach would BEST support fault tolerance?",
          "options": [
            "Implementing circuit breakers and graceful degradation",
            "Using the fastest available algorithms",
            "Minimizing the number of external dependencies",
            "Creating comprehensive user manuals"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Circuit breakers prevent cascading failures by isolating failing components, while graceful degradation allows the system to continue providing reduced functionality during partial failures."
        },
        {
          "question": "What is the primary risk of over-optimizing for a single quality attribute?",
          "options": [
            "It may negatively impact other important quality attributes",
            "It guarantees optimal system performance overall",
            "It simplifies the architectural decision process",
            "It eliminates the need for trade-off analysis"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes often involve trade-offs. Over-optimizing one (e.g., extreme performance) may severely degrade others (e.g., maintainability, security, or cost)."
        },
        {
          "question": "Which practice would MOST improve system testability?",
          "options": [
            "Creating tightly coupled components for simplicity",
            "Implementing complex, interdependent business logic",
            "Designing components with clear interfaces and minimal dependencies",
            "Using global variables for data sharing between components"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Testability is improved when components have clear boundaries, well-defined interfaces, and minimal external dependencies, allowing them to be tested in isolation with appropriate test doubles."
        },
        {
          "question": "What distinguishes the Development View from other architectural views?",
          "options": [
            "It focuses on how code is organized in development environments",
            "It shows runtime process interactions and communications",
            "It maps software components to physical hardware",
            "It describes business concepts and their relationships"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Development View addresses development-time concerns: source code organization, module structure, build dependencies, and configuration management—how developers work with the codebase."
        },
        {
          "question": "Which factor is MOST important when selecting architectural tactics for quality attributes?",
          "options": [
            "The tactics' popularity in recent blog posts",
            "How well tactics address specific, measurable quality goals",
            "The simplicity of implementing each tactic",
            "Whether the team has previously used the tactics"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural tactics should be chosen based on their effectiveness in achieving specific, measurable quality attribute targets identified for the system, not general popularity or familiarity."
        },
        {
          "question": "What is the fundamental purpose of architecture validation and verification?",
          "options": [
            "To ensure the architecture meets stakeholder needs and is correctly implemented",
            "To eliminate all defects from the final system",
            "To create perfect architectural documentation",
            "To guarantee the project will finish early"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Validation ensures the architecture meets stakeholder requirements (building the right thing). Verification ensures the implementation correctly follows the architecture (building it right)."
        },
        {
          "question": "Which architectural concern would be MOST relevant for a system requiring frequent business rule changes?",
          "options": [
            "Maximizing raw computational performance",
            "Minimizing hardware resource usage",
            "Ensuring high modifiability and low change cost",
            "Optimizing for minimal development time"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Frequent business rule changes demand high modifiability—the ease of making changes. This requires architectural decisions that localize business logic and minimize ripple effects from changes."
        },
        {
          "question": "What is the key characteristic of a well-defined component interface?",
          "options": [
            "It exposes all internal implementation details for flexibility",
            "It provides a clear, stable contract while hiding implementation",
            "It changes frequently to accommodate evolving needs",
            "It maximizes the number of parameters for completeness"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Good interfaces provide stable, well-documented contracts that specify what services are provided while hiding how they're implemented, enabling independent evolution of components."
        },
        {
          "question": "Which quality attribute would be MOST impacted by implementing a comprehensive monitoring and alerting system?",
          "options": [
            "Functional Suitability",
            "Reliability (specifically recoverability)",
            "Portability",
            "Compatibility"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Monitoring and alerting directly support reliability by enabling faster detection of issues (improving MTTR - Mean Time To Recovery) and providing data for root cause analysis."
        },
        {
          "question": "What is the primary value of documenting architectural decisions as Architecture Decision Records (ADRs)?",
          "options": [
            "They eliminate the need for other architectural documentation",
            "They capture the rationale and context behind design choices",
            "They serve as detailed implementation specifications",
            "They replace the need for code comments"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ADRs capture not just what was decided, but why—the context, alternatives considered, trade-offs, and consequences. This preserves crucial reasoning that would otherwise be lost."
        },
        {
          "question": "Which architectural consideration is MOST critical for systems with stringent data privacy requirements?",
          "options": [
            "Maximizing development velocity",
            "Ensuring data encryption both in transit and at rest",
            "Using the simplest possible architecture",
            "Minimizing the number of database tables"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Data privacy requires strong security measures, with encryption being fundamental for protecting sensitive data both during transmission and while stored."
        }
      ]
    }
  ]
}
