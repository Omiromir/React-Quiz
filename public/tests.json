{
  "tests": [
    {
      "id": "Software Architecture",
      "name": "Software Architecture Final Test",
      "description": "A comprehensive test covering key concepts in software architecture, including quality attributes, architectural patterns, and design principles.",
      "questions": [
        {
          "question": "In architectural partitioning, what is the primary criterion for determining how to 'sensibly' divide an application into components?",
          "options": [
            "The personal preferences of the development team",
            "Meeting specific application requirements and constraints",
            "Following the latest industry trends regardless of context",
            "Maximizing the number of components for better granularity"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural partitioning must be driven by the specific requirements and constraints of the application itself, not by trends or preferences. Different applications with different requirements will have different sensible partitions."
        },
        {
          "question": "Which statement best describes the relationship between quality attributes and system architecture?",
          "options": [
            "Quality attributes are secondary concerns that can be addressed after functional requirements are implemented",
            "Architecture exists primarily to satisfy quality attributes, not just functional requirements",
            "Quality attributes only affect the user interface layer of the system",
            "Each quality attribute can be maximized independently without affecting others"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architecture fundamentally exists to satisfy quality attributes (performance, security, maintainability, etc.). Functional requirements define what the system does, but quality attributes define how well it does it and directly shape architectural decisions."
        },
        {
          "question": "What is the key difference between non-functional requirements and quality attributes?",
          "options": [
            "Non-functional requirements are technical while quality attributes are business-oriented",
            "Non-functional requirements are vague statements while quality attributes are measurable characteristics",
            "They are synonymous terms for the same concept",
            "Non-functional requirements apply to the development process while quality attributes apply to the final product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Non-functional requirements are often stated informally (e.g., 'system must be fast'), while quality attributes turn these into measurable, actionable characteristics (e.g., 'response time under 2 seconds') that can drive architectural decisions."
        },
        {
          "question": "Which architectural tactic would MOST directly address reliability concerns?",
          "options": [
            "Implementing a comprehensive logging framework",
            "Adding redundancy and failover mechanisms",
            "Using the latest programming language features",
            "Creating detailed documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Reliability focuses on correct performance over time, availability, and fault tolerance. Redundancy and failover mechanisms directly address these by ensuring continued operation even when components fail."
        },
        {
          "question": "What is the fundamental purpose of creating multiple architectural models for the same system?",
          "options": [
            "To increase documentation workload for developers",
            "To satisfy different stakeholder concerns and viewpoints",
            "To demonstrate the architect's versatility in modeling techniques",
            "To provide backup options if one model proves incorrect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Different stakeholders (business users, developers, operations) have different concerns. No single model can address all viewpoints effectively, so multiple models following the principle of separation of concerns are necessary."
        },
        {
          "question": "In the context of ISO/IEC 25010, which quality characteristic would be MOST compromised by choosing a monolithic architecture over microservices?",
          "options": [
            "Functional Suitability",
            "Performance Efficiency",
            "Scalability and Maintainability",
            "Security"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "While monolithic architectures can have advantages, microservices typically offer better scalability (part of Performance Efficiency) and maintainability due to independent deployability and clearer component boundaries."
        },
        {
          "question": "Which element should NEVER appear in a Context Diagram?",
          "options": [
            "External user roles",
            "Interaction flows with external systems",
            "Internal service components",
            "System boundary definition"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "A Context Diagram shows the system as a single black box interacting with its external environment. Showing internal components violates its purpose and turns it into a different type of diagram."
        },
        {
          "question": "What is the primary risk of NOT documenting architectural design decisions?",
          "options": [
            "Increased initial development cost",
            "Loss of rationale and context for future maintainers",
            "Immediate system failure",
            "Violation of coding standards"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions represent trade-offs made based on specific constraints and requirements. Without documenting the rationale (why certain options were chosen over others), future maintainers may misunderstand the architecture or make changes that violate original assumptions."
        },
        {
          "question": "Which quality attribute trade-off is most commonly encountered when implementing extensive caching strategies?",
          "options": [
            "Security vs Usability",
            "Performance vs Data Consistency",
            "Portability vs Functionality",
            "Reliability vs Cost"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Caching improves performance (response time, throughput) but introduces complexity around cache invalidation and data consistency, potentially leading to stale data being served."
        },
        {
          "question": "What distinguishes a Domain Model from a Design Model?",
          "options": [
            "Domain Models use UML while Design Models use pseudocode",
            "Domain Models describe business concepts while Design Models describe technical implementation",
            "Domain Models are created by developers while Design Models are created by business analysts",
            "Domain Models focus on performance while Design Models focus on functionality"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A Domain Model captures business concepts, relationships, and rules in business language, independent of technology. A Design Model translates these into technical components, services, and implementation structures."
        },
        {
          "question": "Why is it particularly challenging to validate architectural decisions early in a project lifecycle?",
          "options": [
            "Stakeholders are unavailable for consultation early on",
            "Many decisions cannot be fully tested until parts of the system are built",
            "Architects lack sufficient information to make any decisions early on",
            "Early validation requires complete system specification"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions involve system-wide concerns that often depend on interactions between components. These interactions and their consequences may only become apparent when significant portions of the system are implemented and integrated."
        },
        {
          "question": "Which of the following is a key benefit of using architectural patterns?",
          "options": [
            "They eliminate the need for custom design work",
            "They provide proven solutions with known engineering trade-offs",
            "They guarantee optimal performance for any application",
            "They automatically generate implementation code"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural patterns encode proven solutions to common problems, along with their known benefits and trade-offs. This allows architects to leverage collective experience rather than inventing solutions from scratch."
        },
        {
          "question": "What role does a 'marketeecture' play in the architectural process?",
          "options": [
            "It serves as the final technical specification for developers",
            "It facilitates stakeholder communication and high-level understanding",
            "It replaces the need for detailed architectural documentation",
            "It provides performance benchmarks for the system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A marketeecture is a simplified, high-level visualization that helps non-technical stakeholders understand the system's value proposition and basic structure, facilitating discussion and alignment."
        },
        {
          "question": "Which quality attribute would be MOST directly improved by implementing an API-first design approach?",
          "options": [
            "Reliability",
            "Compatibility",
            "Security",
            "Portability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "API-first design, with stable contracts and versioning strategies, directly improves compatibility by ensuring clear, consistent interfaces for system interaction and data exchange."
        },
        {
          "question": "What is the primary purpose of hierarchical decomposition in architectural description?",
          "options": [
            "To hide complexity by revealing details only at appropriate abstraction levels",
            "To create more documentation than necessary",
            "To demonstrate all possible implementation paths",
            "To eliminate the need for multiple architectural views"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Hierarchical decomposition allows architects to manage complexity by presenting the architecture at different levels of detail. High-level views show major components and relationships, while lower levels reveal internal structures only when necessary."
        },
        {
          "question": "Which architectural view would be MOST useful for infrastructure teams planning server deployment?",
          "options": [
            "Logical View",
            "Process View",
            "Physical View",
            "Development View"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "The Physical View shows how software components are mapped to hardware resources, which is essential for infrastructure teams responsible for deployment, scaling, and hardware provisioning."
        },
        {
          "question": "What distinguishes responsibility-driven design from other component identification approaches?",
          "options": [
            "It focuses on assigning specific tasks and behaviors to components",
            "It prioritizes minimizing the number of components above all else",
            "It requires components to be implemented in object-oriented languages only",
            "It emphasizes data structures over component behavior"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Responsibility-driven design focuses on what each component should be responsible for—what tasks it performs and what behaviors it exhibits—which helps create cohesive, well-defined components with clear purposes."
        },
        {
          "question": "Which statement BEST describes the relationship between functional requirements and quality attributes?",
          "options": [
            "Functional requirements are more important than quality attributes",
            "Quality attributes constrain how functional requirements are implemented",
            "They are independent concerns that can be addressed separately",
            "Quality attributes are only relevant after functional requirements are satisfied"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Quality attributes (performance, security, etc.) dictate constraints on how functional requirements are implemented. For example, a 'place order' function must be implemented securely, performantly, and reliably."
        },
        {
          "question": "What is the primary value of creating an Informational Model separate from a Domain Model?",
          "options": [
            "It focuses purely on data structures independently of business meaning",
            "It serves as a technical database schema for implementation",
            "It replaces the need for database administrators",
            "It ensures all business rules are encoded in the data layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "An Informational Model focuses on the structure, relationships, and integrity of data itself, separate from the business semantics captured in the Domain Model. This separation allows clearer thinking about data design."
        },
        {
          "question": "Which architectural decision would MOST significantly impact system portability?",
          "options": [
            "Choosing a specific cloud provider's proprietary services",
            "Implementing comprehensive error logging",
            "Using design patterns in the codebase",
            "Creating detailed API documentation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Portability refers to the ease of moving the system between environments. Vendor lock-in through proprietary services severely reduces portability, while containerization and abstraction layers enhance it."
        },
        {
          "question": "What is the fundamental purpose of architectural validation?",
          "options": [
            "To ensure the architecture will satisfy quality attributes before major implementation",
            "To eliminate all risks from the development process",
            "To create perfect documentation for all stakeholders",
            "To guarantee the project will be delivered on time"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Architectural validation techniques (prototyping, analysis, simulation) aim to verify that the chosen architecture will meet critical quality requirements before substantial resources are committed to implementation."
        },
        {
          "question": "Which quality attribute is MOST directly addressed by implementing authentication, authorization, and encryption?",
          "options": [
            "Reliability",
            "Security",
            "Usability",
            "Maintainability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "These are core security mechanisms that address confidentiality (encryption), authenticity (authentication), and authorization (access control)—all sub-characteristics of Security in ISO 25010."
        },
        {
          "question": "What is the key insight behind using metrics for quality attributes?",
          "options": [
            "Metrics make abstract quality attributes measurable and comparable",
            "Metrics eliminate the need for architectural expertise",
            "All quality attributes can be reduced to a single metric",
            "Metrics are only useful for performance-related attributes"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Metrics transform vague quality goals (e.g., 'good performance') into measurable targets (e.g., '95th percentile response time < 200ms'), enabling objective evaluation, comparison, and trade-off analysis."
        },
        {
          "question": "Which scenario BEST illustrates a business constraint (as opposed to a technical constraint)?",
          "options": [
            "The application must use Java because the team only has Java expertise",
            "The database must run on Linux for security reasons",
            "The system must integrate with a specific partner's API to access their customer base",
            "The server must have at least 16GB RAM for adequate performance"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Business constraints arise from commercial, strategic, or operational business decisions rather than technical limitations. Integration for market access is a business-driven constraint."
        },
        {
          "question": "What is the primary danger of treating quality attributes as afterthoughts in architecture?",
          "options": [
            "They can become impossible or extremely costly to add later",
            "They only affect non-critical parts of the system",
            "They are easily retrofitted into any existing architecture",
            "They primarily impact only the user interface layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes like scalability, security, and maintainability often require fundamental architectural decisions. Retrofitting them later can require major rework, if it's possible at all."
        },
        {
          "question": "Which architectural style would be MOST appropriate for a system requiring independent scalability of different functional areas?",
          "options": [
            "Monolithic Architecture",
            "Layered Architecture",
            "Microservices Architecture",
            "Client-Server Architecture"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Microservices allow individual services to be scaled independently based on their specific load requirements, unlike monolithic architectures where the entire application scales together."
        },
        {
          "question": "What is the key characteristic of the Process View in architectural modeling?",
          "options": [
            "It focuses on concurrency, communication, and runtime behavior",
            "It shows the mapping of software to hardware resources",
            "It describes the static structure using class-like elements",
            "It organizes code in development environments"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Process View addresses runtime concerns: how components execute (threads, processes), how they communicate (synchronously/asynchronously), and how they handle concurrency."
        },
        {
          "question": "Which practice would MOST improve system maintainability?",
          "options": [
            "Implementing tight coupling between components for simplicity",
            "Creating clear component boundaries with low coupling and high cohesion",
            "Using the fewest possible components regardless of responsibility",
            "Writing all code in a single programming language"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Maintainability depends on how easily the system can be modified. Clear boundaries with low coupling (minimal dependencies) and high cohesion (related functionality together) make changes more localized and predictable."
        },
        {
          "question": "What is the fundamental purpose of stakeholder requirements analysis?",
          "options": [
            "To create technical specifications for developers",
            "To align development with business goals and user needs before building",
            "To eliminate all communication with non-technical stakeholders",
            "To produce marketing materials for the product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stakeholder requirements capture the needs, expectations, and constraints of all parties involved. This alignment ensures the resulting system delivers real value and meets actual needs."
        },
        {
          "question": "Which architectural consideration is MOST critical when designing for high availability?",
          "options": [
            "Minimizing the number of external dependencies",
            "Eliminating all single points of failure",
            "Using the fastest available hardware",
            "Implementing the most sophisticated algorithms"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "High availability requires that no single component failure can bring down the entire system. This typically involves redundancy, failover mechanisms, and distributed architectures."
        },
        {
          "question": "What distinguishes explicit requirements from implicit requirements?",
          "options": [
            "Explicit requirements are documented while implicit ones are assumed",
            "Explicit requirements are technical while implicit ones are business-related",
            "Explicit requirements change frequently while implicit ones are stable",
            "Explicit requirements are optional while implicit ones are mandatory"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Explicit requirements are formally stated and documented. Implicit requirements are unstated assumptions or expectations that stakeholders believe are obvious but may not be captured formally, leading to potential misunderstandings."
        },
        {
          "question": "Which factor MOST influences the choice between synchronous and asynchronous communication between components?",
          "options": [
            "The programming language used for implementation",
            "Performance requirements and coupling tolerance",
            "The preferences of the development team",
            "The cost of development tools"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Synchronous communication (tight coupling, simpler) vs asynchronous (looser coupling, more complex) involves trade-offs between performance, reliability, and system complexity that must align with quality requirements."
        },
        {
          "question": "What is the primary purpose of architectural prototyping?",
          "options": [
            "To create a fully functional version of the system",
            "To validate technical risks and architectural hypotheses",
            "To replace the need for requirements analysis",
            "To serve as the final production system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural prototypes focus on validating specific high-risk aspects of the architecture (performance, integration, etc.) rather than building complete functionality."
        },
        {
          "question": "Which quality attribute would be MOST affected by implementing a Backend-for-Frontend (BFF) pattern?",
          "options": ["Security", "Usability", "Portability", "Reliability"],
          "correctOption": 1,
          "points": 10,
          "explanation": "BFF creates separate backend services tailored to specific frontend needs, improving usability by optimizing data delivery and interactions for each user interface context."
        },
        {
          "question": "What is the key benefit of using Commercial Off-The-Shelf (COTS) technologies that implement architectural patterns?",
          "options": [
            "They eliminate all customization needs",
            "They provide proven implementations of architectural approaches",
            "They guarantee the best performance for any use case",
            "They reduce the need for architectural design altogether"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "COTS technologies (like message brokers, application servers) provide ready-made, tested implementations of common architectural patterns, reducing development risk and effort."
        },
        {
          "question": "Which practice would MOST improve system analysability (ease of understanding the system)?",
          "options": [
            "Using short, cryptic variable names to save space",
            "Creating complex, deeply nested component hierarchies",
            "Implementing clear module decomposition with meaningful names",
            "Minimizing documentation to avoid outdated information"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Analysability, a sub-characteristic of Maintainability, is improved by clear organization, meaningful naming, and logical decomposition that helps developers understand system structure and behavior."
        },
        {
          "question": "What is the fundamental challenge in balancing security and usability?",
          "options": [
            "They are mutually exclusive and cannot coexist",
            "Increased security measures often create user friction",
            "Usability always compromises security effectiveness",
            "Security is only relevant for administrative users"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Strong security (multi-factor authentication, frequent re-authentication, complex passwords) can hinder usability. Architects must find balanced solutions that provide adequate security without excessive user burden."
        },
        {
          "question": "Which architectural decision would MOST directly address scalability concerns?",
          "options": [
            "Implementing comprehensive audit logging",
            "Using stateless services with horizontal scaling",
            "Choosing a specific programming language",
            "Creating detailed user documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stateless services can be easily replicated across multiple servers (horizontal scaling), allowing the system to handle increased load by adding more instances rather than upgrading single servers."
        },
        {
          "question": "What is the primary value of the ISO/IEC 25010 quality model?",
          "options": [
            "It provides a complete checklist of all possible system features",
            "It offers a standardized vocabulary for discussing system quality",
            "It eliminates the need for architectural decision-making",
            "It guarantees specific performance levels for any system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ISO 25010 provides a shared, standardized framework for discussing, specifying, and evaluating software quality characteristics, enabling clearer communication between stakeholders."
        },
        {
          "question": "Which factor is MOST critical when evaluating architectural alternatives?",
          "options": [
            "The popularity of each alternative in the industry",
            "How well each addresses the specific quality attribute priorities",
            "The complexity of implementation for each alternative",
            "The personal preferences of the architect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions should be driven by how well alternatives satisfy the prioritized quality attributes for the specific system context, not by general popularity or personal preference."
        },
        {
          "question": "What is the key insight about system failures according to the quality attributes lecture?",
          "options": [
            "Most failures are caused by missing features rather than quality issues",
            "Quality issues cause more system failures than missing functionality",
            "Failures are evenly distributed between functional and quality issues",
            "Failures are primarily caused by hardware rather than software issues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "The lecture emphasizes that systems with identical features can have very different success based on quality attributes, and that quality issues (performance, reliability, security) often cause more problems than missing features."
        },
        {
          "question": "Which architectural approach would BEST support fault tolerance?",
          "options": [
            "Implementing circuit breakers and graceful degradation",
            "Using the fastest available algorithms",
            "Minimizing the number of external dependencies",
            "Creating comprehensive user manuals"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Circuit breakers prevent cascading failures by isolating failing components, while graceful degradation allows the system to continue providing reduced functionality during partial failures."
        },
        {
          "question": "What is the primary risk of over-optimizing for a single quality attribute?",
          "options": [
            "It may negatively impact other important quality attributes",
            "It guarantees optimal system performance overall",
            "It simplifies the architectural decision process",
            "It eliminates the need for trade-off analysis"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes often involve trade-offs. Over-optimizing one (e.g., extreme performance) may severely degrade others (e.g., maintainability, security, or cost)."
        },
        {
          "question": "Which practice would MOST improve system testability?",
          "options": [
            "Creating tightly coupled components for simplicity",
            "Implementing complex, interdependent business logic",
            "Designing components with clear interfaces and minimal dependencies",
            "Using global variables for data sharing between components"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Testability is improved when components have clear boundaries, well-defined interfaces, and minimal external dependencies, allowing them to be tested in isolation with appropriate test doubles."
        },
        {
          "question": "What distinguishes the Development View from other architectural views?",
          "options": [
            "It focuses on how code is organized in development environments",
            "It shows runtime process interactions and communications",
            "It maps software components to physical hardware",
            "It describes business concepts and their relationships"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Development View addresses development-time concerns: source code organization, module structure, build dependencies, and configuration management—how developers work with the codebase."
        },
        {
          "question": "Which factor is MOST important when selecting architectural tactics for quality attributes?",
          "options": [
            "The tactics' popularity in recent blog posts",
            "How well tactics address specific, measurable quality goals",
            "The simplicity of implementing each tactic",
            "Whether the team has previously used the tactics"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural tactics should be chosen based on their effectiveness in achieving specific, measurable quality attribute targets identified for the system, not general popularity or familiarity."
        },
        {
          "question": "What is the fundamental purpose of architecture validation and verification?",
          "options": [
            "To ensure the architecture meets stakeholder needs and is correctly implemented",
            "To eliminate all defects from the final system",
            "To create perfect architectural documentation",
            "To guarantee the project will finish early"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Validation ensures the architecture meets stakeholder requirements (building the right thing). Verification ensures the implementation correctly follows the architecture (building it right)."
        },
        {
          "question": "Which architectural concern would be MOST relevant for a system requiring frequent business rule changes?",
          "options": [
            "Maximizing raw computational performance",
            "Minimizing hardware resource usage",
            "Ensuring high modifiability and low change cost",
            "Optimizing for minimal development time"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Frequent business rule changes demand high modifiability—the ease of making changes. This requires architectural decisions that localize business logic and minimize ripple effects from changes."
        },
        {
          "question": "What is the key characteristic of a well-defined component interface?",
          "options": [
            "It exposes all internal implementation details for flexibility",
            "It provides a clear, stable contract while hiding implementation",
            "It changes frequently to accommodate evolving needs",
            "It maximizes the number of parameters for completeness"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Good interfaces provide stable, well-documented contracts that specify what services are provided while hiding how they're implemented, enabling independent evolution of components."
        },
        {
          "question": "Which quality attribute would be MOST impacted by implementing a comprehensive monitoring and alerting system?",
          "options": [
            "Functional Suitability",
            "Reliability (specifically recoverability)",
            "Portability",
            "Compatibility"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Monitoring and alerting directly support reliability by enabling faster detection of issues (improving MTTR - Mean Time To Recovery) and providing data for root cause analysis."
        },
        {
          "question": "What is the primary value of documenting architectural decisions as Architecture Decision Records (ADRs)?",
          "options": [
            "They eliminate the need for other architectural documentation",
            "They capture the rationale and context behind design choices",
            "They serve as detailed implementation specifications",
            "They replace the need for code comments"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ADRs capture not just what was decided, but why—the context, alternatives considered, trade-offs, and consequences. This preserves crucial reasoning that would otherwise be lost."
        },
        {
          "question": "Which architectural consideration is MOST critical for systems with stringent data privacy requirements?",
          "options": [
            "Maximizing development velocity",
            "Ensuring data encryption both in transit and at rest",
            "Using the simplest possible architecture",
            "Minimizing the number of database tables"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Data privacy requires strong security measures, with encryption being fundamental for protecting sensitive data both during transmission and while stored."
        }
      ]
    },
    {
      "id": "Infobez variant 1",
      "name": "Infobez variant 1",
      "description": "A quiz on infobez",
      "questions": [
        {
          "question": "Which security objective focuses on preventing unauthorized disclosure of information?",
          "options": [
            "Availability",
            "Confidentiality",
            "Nonrepudiation",
            "Auditability",
            "Resilience"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Confidentiality ensures that information is not disclosed to unauthorized individuals, entities, or processes. It's one of the three core security principles in the CIA triad (Confidentiality, Integrity, Availability)."
        },
        {
          "question": "Which term best describes data stored on a disk that is not currently being transmitted?",
          "options": [
            "Data in transit",
            "Data in process",
            "Data at rest",
            "Ephemeral data",
            "Streaming data"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Data at rest refers to data that is stored physically in any digital form (disks, databases, backups) and is not actively moving between systems. This requires encryption and access controls for protection."
        },
        {
          "question": "Which technology most directly protects data confidentiality when employees access internal resources over the Internet?",
          "options": ["VPN", "VLAN", "NAT", "DNS", "ARP"],
          "correctOption": 0,
          "points": 10,
          "explanation": "VPN (Virtual Private Network) creates an encrypted tunnel between the user and the corporate network, ensuring that data transmitted over the public internet remains confidential and protected from eavesdropping."
        },
        {
          "question": "What is the main advantage of Network Attached Storage (NAS) compared to direct-attached storage for multiple users?",
          "options": [
            "It cannot be shared",
            "It is accessible over a network for authorized users",
            "It requires no authentication",
            "It replaces encryption",
            "It eliminates backups"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "NAS provides centralized storage that can be accessed over a network by multiple authorized users, enabling file sharing, collaboration, and centralized backup/management compared to direct-attached storage which is limited to a single system."
        },
        {
          "question": "Which principle says users should be granted only the permissions necessary to do their job?",
          "options": [
            "Fail-open design",
            "Least privilege",
            "Default allow",
            "Obscurity",
            "Single point of control"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "The principle of least privilege minimizes security risks by ensuring users and systems have only the minimum access rights needed to perform their functions, reducing the attack surface and potential damage from compromised accounts."
        },
        {
          "question": "In an access control list (ACL), why is rule order important?",
          "options": [
            "Rules are evaluated from top to bottom and the first match is applied",
            "Routers ignore the first rule",
            "Only the last rule is enforced",
            "Order matters only for NAT",
            "Order matters only on switches"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "ACLs are processed sequentially from the first rule to the last, and the first matching rule determines the action (permit/deny). This makes rule order critical, as an overly permissive early rule can override more restrictive later rules."
        },
        {
          "question": "What is the typical default behavior at the end of a Cisco ACL if no rule matches?",
          "options": [
            "Implicit permit",
            "Implicit deny",
            "Automatic NAT",
            "Automatic encryption",
            "Automatic logging"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Cisco ACLs include an implicit deny any rule at the end of every ACL, which denies all traffic not explicitly permitted by previous rules. This follows the security best practice of 'deny by default'."
        },
        {
          "question": "An ACL applied in the 'out' direction on an interface filters packets that are:",
          "options": [
            "Entering the interface",
            "Leaving the interface",
            "Only broadcast packets",
            "Only multicast packets",
            "Only management traffic"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Outbound ACLs filter packets as they leave the interface (egress traffic). This allows control over what traffic exits a network segment, which is useful for filtering internal traffic before it reaches external networks."
        },
        {
          "question": "Which command is commonly used to display configured ACLs on a Cisco IOS router?",
          "options": [
            "show access-lists",
            "show arp",
            "show vlan brief",
            "show cdp neighbors",
            "show controllers"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The 'show access-lists' command displays all configured ACLs, their rules, and hit counts (packet matches), which is essential for troubleshooting and verifying ACL configurations."
        },
        {
          "question": "Which Linux file typically contains password hashes (and is readable only by privileged users)?",
          "options": [
            "/etc/passwd",
            "/etc/group",
            "/etc/shadow",
            "/etc/hosts",
            "/etc/resolv.conf"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "/etc/shadow stores password hashes with additional security information (password aging, expiration) and is readable only by root, while /etc/passwd contains basic user information that's world-readable."
        },
        {
          "question": "What is the primary purpose of password hashing for stored credentials?",
          "options": [
            "To make passwords reversible for admins",
            "To store a one-way representation of the password",
            "To compress passwords to save space",
            "To convert passwords to Base64",
            "To enable faster login without security checks"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Hashing converts passwords into fixed-size, irreversible representations. This prevents attackers (and even administrators) from recovering the original password while allowing the system to verify passwords by comparing hashes."
        },
        {
          "question": "Which is a key difference between encryption and hashing?",
          "options": [
            "Encryption is one-way; hashing is reversible",
            "Encryption is reversible with a key; hashing is designed to be one-way",
            "Hashing requires a private key; encryption does not",
            "Hashing guarantees confidentiality; encryption does not",
            "They are the same concept"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Encryption is a two-way process that requires a key to both encrypt and decrypt data, while hashing is a one-way function that produces a fixed-size output (hash) that cannot be reversed to obtain the original input."
        },
        {
          "question": "Base64 is best described as:",
          "options": [
            "A strong encryption algorithm",
            "A compression algorithm",
            "An encoding method to represent binary data as text",
            "A hashing algorithm",
            "A VPN protocol"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Base64 is an encoding scheme that converts binary data into ASCII text format, making it suitable for transmission over text-based protocols like email or embedding in web pages. It provides no security - it's not encryption."
        },
        {
          "question": "Which property is primarily provided by a cryptographic hash in secure communications?",
          "options": [
            "Confidentiality",
            "Integrity",
            "Availability",
            "Routing",
            "Load balancing"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Cryptographic hashes verify data integrity by producing a unique fingerprint of data. Any alteration to the data changes the hash, allowing detection of tampering or corruption during transmission or storage."
        },
        {
          "question": "In symmetric encryption, the sender and receiver typically use:",
          "options": [
            "Different keys",
            "The same shared secret key",
            "Only public keys",
            "Only certificates",
            "No keys"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Symmetric encryption uses a single shared secret key for both encryption and decryption. It's faster than asymmetric encryption but requires secure key distribution since both parties must have the same key."
        },
        {
          "question": "Why is adding a salt (or random value) helpful when protecting stored passwords?",
          "options": [
            "It makes passwords shorter",
            "It prevents two identical passwords from having identical hashes",
            "It disables brute-force attempts permanently",
            "It replaces the need for hashing",
            "It increases network bandwidth"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Salting adds random data to each password before hashing, ensuring that identical passwords produce different hashes. This prevents rainbow table attacks and makes precomputed attacks impractical since each hash is unique."
        },
        {
          "question": "Which is the best example of a control that helps detect unauthorized changes to critical records?",
          "options": [
            "Turning off logs",
            "Audit logging and change tracking",
            "Removing access control",
            "Using default passwords",
            "Disabling backups"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Audit logging creates detailed records of who accessed what data, when, and what changes were made. This enables detection of unauthorized modifications and supports forensic investigations after security incidents."
        },
        {
          "question": "What does strong authentication most directly improve?",
          "options": [
            "The number of available IP addresses",
            "Confidence that a user is who they claim to be",
            "The physical durability of disks",
            "The speed of encryption",
            "The size of backups"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Strong authentication mechanisms (multi-factor, biometrics, hardware tokens) increase assurance that users are genuine, reducing the risk of unauthorized access from stolen credentials or identity spoofing."
        },
        {
          "question": "Which statement about password strength is most accurate?",
          "options": [
            "Length and unpredictability generally increase resistance to guessing attacks",
            "Short passwords with symbols are always strongest",
            "Using a common word is fine if it is capitalized",
            "Reusing passwords reduces risk",
            "Passwords do not need to be changed"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Longer, complex passwords with random character combinations are more resistant to brute-force and dictionary attacks. Modern guidelines emphasize length over complexity, with passphrases being more secure than short complex passwords."
        },
        {
          "question": "A role-based access control (RBAC) model assigns permissions primarily based on:",
          "options": [
            "Physical location",
            "User roles or job functions",
            "Browser type",
            "Time of day only",
            "IP address only"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "RBAC assigns permissions to roles rather than individual users, and users are assigned to roles based on their job functions. This simplifies administration, ensures consistency, and makes it easier to enforce least privilege."
        }
      ]
    },
    {
      "id": "Infobez variant 2",
      "name": "Infobez variant 2",
      "description": "A quiz on infobez",
      "questions": [
        {
          "question": "Which term describes information being actively handled by an application (e.g., in RAM or CPU during computation)?",
          "options": [
            "Data at rest",
            "Data in transit",
            "Data in process",
            "Archived data",
            "Cold data"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Data in process (or data in use) refers to data currently being processed by applications in memory or CPU. This is one of the three states of digital data (at rest, in transit, in process) that require different security protections."
        },
        {
          "question": "Which control best reduces the risk of unauthorized access if a laptop is lost?",
          "options": [
            "Disk encryption",
            "Disabling updates",
            "Using default admin accounts",
            "Turning off the firewall",
            "Sharing passwords"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Full disk encryption (FDE) protects data at rest by encrypting the entire storage drive. Even if a laptop is lost or stolen, the data remains inaccessible without the encryption key or password, preventing unauthorized access to sensitive information."
        },
        {
          "question": "Which concept refers to proving that a specific action was performed by a particular user and cannot be denied later?",
          "options": [
            "Availability",
            "Nonrepudiation",
            "Confidentiality",
            "Steganography",
            "Load balancing"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Nonrepudiation provides proof of the origin and integrity of data, ensuring that a party cannot deny having performed an action. This is typically achieved through digital signatures, audit trails, and logging mechanisms in secure systems."
        },
        {
          "question": "What is the main purpose of an Initialization Vector (IV) in many encryption modes?",
          "options": [
            "To replace the key",
            "To add randomness so identical plaintext blocks encrypt differently",
            "To compress the ciphertext",
            "To verify user identity",
            "To disable replay protection"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "An Initialization Vector is a random or pseudo-random value used to ensure that identical plaintext blocks produce different ciphertext blocks when encrypted. This prevents pattern recognition attacks and adds semantic security to encryption."
        },
        {
          "question": "Which of the following most directly provides confidentiality for a file stored on disk?",
          "options": [
            "Symmetric encryption (e.g., AES)",
            "Hashing (e.g., SHA-256)",
            "Encoding (Base64)",
            "Routing",
            "DHCP"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Symmetric encryption like AES (Advanced Encryption Standard) directly provides confidentiality by transforming plaintext into ciphertext using a secret key, ensuring that only authorized parties with the key can access the original data."
        },
        {
          "question": "Which statement about ACLs is correct?",
          "options": [
            "ACLs can be used to permit or deny traffic based on defined criteria",
            "ACLs automatically encrypt traffic",
            "ACLs replace routing protocols",
            "ACLs work only on end-user PCs",
            "ACLs are the same as backups"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Access Control Lists (ACLs) are rule-based security mechanisms that filter network traffic by permitting or denying packets based on criteria like source/destination IP addresses, ports, and protocols. They don't encrypt traffic or replace routing."
        },
        {
          "question": "A 'standard' IPv4 ACL in Cisco IOS typically filters traffic based on:",
          "options": [
            "Source IP address only",
            "Destination port only",
            "Application layer payload",
            "MAC address only",
            "Wireless SSID"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Standard ACLs in Cisco IOS (numbered 1-99, 1300-1999) filter based solely on source IP address. Extended ACLs (100-199, 2000-2699) can filter on source/destination IP, ports, protocols, and other criteria."
        },
        {
          "question": "When troubleshooting why traffic is blocked, which step is most relevant?",
          "options": [
            "Check ACL rule order and interface direction",
            "Increase screen brightness",
            "Disable routing",
            "Delete DNS records",
            "Turn off logging"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "ACL troubleshooting involves verifying rule order (first match applies), direction (inbound/outbound), interface application, and specific permit/deny statements. These factors determine which traffic is allowed or blocked."
        },
        {
          "question": "Which Linux command is commonly used to display the contents of a text file to the terminal?",
          "options": ["cat", "mv", "chmod", "grep -v", "sudoers"],
          "correctOption": 0,
          "points": 10,
          "explanation": "The 'cat' (concatenate) command reads files sequentially and writes their contents to standard output. It's one of the most basic and frequently used commands for viewing file contents in Linux/Unix systems."
        },
        {
          "question": "Which statement about OpenSSL usage is most accurate?",
          "options": [
            "OpenSSL can encrypt and decrypt data from the command line",
            "OpenSSL is only for routing configuration",
            "OpenSSL automatically guarantees integrity in all modes",
            "OpenSSL replaces access control",
            "OpenSSL is a file compression tool"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "OpenSSL is a robust, full-featured toolkit implementing SSL/TLS protocols and general-purpose cryptography. It provides command-line tools for encryption, decryption, certificate management, and cryptographic operations."
        },
        {
          "question": "What does the -d option indicate in many command-line encryption tools (including typical OpenSSL usage)?",
          "options": ["Decrypt", "Delete", "Download", "Duplicate", "Diagnose"],
          "correctOption": 0,
          "points": 10,
          "explanation": "In encryption tools like OpenSSL, the '-d' flag typically stands for 'decrypt,' instructing the tool to perform decryption rather than encryption. This convention is common across many cryptographic utilities."
        },
        {
          "question": "Which is the best description of Base64 output when encrypting a file?",
          "options": [
            "It makes ciphertext human-readable for transport, but does not add security",
            "It is stronger than AES",
            "It converts ciphertext into plaintext",
            "It disables passwords",
            "It guarantees integrity"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Base64 encoding converts binary data (like encrypted ciphertext) into ASCII text format, making it safe for transmission through text-based systems. It provides no cryptographic security—it's purely an encoding scheme."
        },
        {
          "question": "Which is a common reason to keep encrypted outputs ASCII-friendly?",
          "options": [
            "To safely copy/paste or transmit through text-only channels",
            "To reduce CPU usage to zero",
            "To disable authentication",
            "To increase Wi-Fi range",
            "To bypass permissions"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "ASCII-friendly formats (like Base64) allow encrypted data to be safely embedded in emails, web forms, configuration files, and other text-based systems without corruption from binary characters that might be misinterpreted."
        },
        {
          "question": "Which pair correctly matches purpose to tool?",
          "options": [
            "Encryption – confidentiality",
            "Encoding – confidentiality",
            "Hashing – confidentiality",
            "Routing – integrity",
            "DNS – nonrepudiation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Encryption specifically provides confidentiality by making data unreadable without proper authorization. Hashing provides integrity, encoding enables compatibility, routing directs network traffic, and DNS resolves domain names—none provide confidentiality."
        },
        {
          "question": "What is the main security drawback of encryption without integrity checks (e.g., no MAC/authenticated mode)?",
          "options": [
            "Ciphertext could be modified without detection",
            "It uses too much disk space",
            "It prevents backups",
            "It cannot be decrypted",
            "It forces password reuse"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Encryption without integrity protection (like AES in ECB or CBC mode without HMAC) is vulnerable to tampering. Attackers can modify ciphertext, potentially altering the decrypted plaintext without the recipient detecting the changes."
        },
        {
          "question": "Which answer best describes why long passwords are harder to guess?",
          "options": [
            "They increase the search space (entropy)",
            "They always contain symbols",
            "They disable brute-force tools",
            "They remove the need for a key",
            "They reduce encryption strength"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Password length exponentially increases the possible combinations (entropy), making brute-force attacks computationally impractical. Each additional character multiplies the search space, significantly increasing the time required to guess the password."
        },
        {
          "question": "Which practice best helps prevent credential exposure across multiple services?",
          "options": [
            "Reuse the same password everywhere",
            "Use unique passwords per service",
            "Store passwords in plain text",
            "Disable two-factor authentication",
            "Share passwords with colleagues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Using unique passwords for each service limits damage from credential stuffing attacks and data breaches. If one service is compromised, attackers cannot reuse those credentials to access other accounts (password reuse is a major security risk)."
        },
        {
          "question": "Which statement about /etc/passwd is generally correct?",
          "options": [
            "It contains user account info; hashes are stored elsewhere on modern systems",
            "It stores Wi-Fi keys",
            "It stores router ACLs",
            "It stores only encrypted zip archives",
            "It is a log file"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "On modern Unix/Linux systems, /etc/passwd stores user account information (username, UID, GID, home directory, shell) but not password hashes, which are moved to /etc/shadow for enhanced security (shadow password suite)."
        },
        {
          "question": "Which control most directly supports accountability in systems handling sensitive changes?",
          "options": [
            "Audit logs with user identity and timestamps",
            "Turning off authentication",
            "Anonymous shared accounts",
            "Removing approvals",
            "Disabling backups"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Comprehensive audit logging that records who performed what action, when, and from where establishes accountability. This enables tracing actions to specific individuals, supporting investigations, compliance, and deterring malicious activity."
        },
        {
          "question": "Which of these is a typical secure practice for remote administrative access?",
          "options": [
            "Use SSH with strong authentication",
            "Use Telnet in plaintext",
            "Use shared root passwords",
            "Disable logging",
            "Use open Wi-Fi without encryption"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "SSH (Secure Shell) with strong authentication (key-based, multi-factor) provides encrypted remote administration, protecting credentials and data from eavesdropping. Telnet sends credentials in plaintext and should never be used for administrative access."
        }
      ]
    }
  ]
}
