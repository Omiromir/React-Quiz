{
  "tests": [
    {
      "id": "Software Architecture",
      "name": "Software Architecture Final Test",
      "description": "A comprehensive test covering key concepts in software architecture, including quality attributes, architectural patterns, and design principles.",
      "questions": [
        {
          "question": "In architectural partitioning, what is the primary criterion for determining how to 'sensibly' divide an application into components?",
          "options": [
            "The personal preferences of the development team",
            "Meeting specific application requirements and constraints",
            "Following the latest industry trends regardless of context",
            "Maximizing the number of components for better granularity"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural partitioning must be driven by the specific requirements and constraints of the application itself, not by trends or preferences. Different applications with different requirements will have different sensible partitions."
        },
        {
          "question": "Which statement best describes the relationship between quality attributes and system architecture?",
          "options": [
            "Quality attributes are secondary concerns that can be addressed after functional requirements are implemented",
            "Architecture exists primarily to satisfy quality attributes, not just functional requirements",
            "Quality attributes only affect the user interface layer of the system",
            "Each quality attribute can be maximized independently without affecting others"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architecture fundamentally exists to satisfy quality attributes (performance, security, maintainability, etc.). Functional requirements define what the system does, but quality attributes define how well it does it and directly shape architectural decisions."
        },
        {
          "question": "What is the key difference between non-functional requirements and quality attributes?",
          "options": [
            "Non-functional requirements are technical while quality attributes are business-oriented",
            "Non-functional requirements are vague statements while quality attributes are measurable characteristics",
            "They are synonymous terms for the same concept",
            "Non-functional requirements apply to the development process while quality attributes apply to the final product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Non-functional requirements are often stated informally (e.g., 'system must be fast'), while quality attributes turn these into measurable, actionable characteristics (e.g., 'response time under 2 seconds') that can drive architectural decisions."
        },
        {
          "question": "Which architectural tactic would MOST directly address reliability concerns?",
          "options": [
            "Implementing a comprehensive logging framework",
            "Adding redundancy and failover mechanisms",
            "Using the latest programming language features",
            "Creating detailed documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Reliability focuses on correct performance over time, availability, and fault tolerance. Redundancy and failover mechanisms directly address these by ensuring continued operation even when components fail."
        },
        {
          "question": "What is the fundamental purpose of creating multiple architectural models for the same system?",
          "options": [
            "To increase documentation workload for developers",
            "To satisfy different stakeholder concerns and viewpoints",
            "To demonstrate the architect's versatility in modeling techniques",
            "To provide backup options if one model proves incorrect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Different stakeholders (business users, developers, operations) have different concerns. No single model can address all viewpoints effectively, so multiple models following the principle of separation of concerns are necessary."
        },
        {
          "question": "In the context of ISO/IEC 25010, which quality characteristic would be MOST compromised by choosing a monolithic architecture over microservices?",
          "options": [
            "Functional Suitability",
            "Performance Efficiency",
            "Scalability and Maintainability",
            "Security"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "While monolithic architectures can have advantages, microservices typically offer better scalability (part of Performance Efficiency) and maintainability due to independent deployability and clearer component boundaries."
        },
        {
          "question": "Which element should NEVER appear in a Context Diagram?",
          "options": [
            "External user roles",
            "Interaction flows with external systems",
            "Internal service components",
            "System boundary definition"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "A Context Diagram shows the system as a single black box interacting with its external environment. Showing internal components violates its purpose and turns it into a different type of diagram."
        },
        {
          "question": "What is the primary risk of NOT documenting architectural design decisions?",
          "options": [
            "Increased initial development cost",
            "Loss of rationale and context for future maintainers",
            "Immediate system failure",
            "Violation of coding standards"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions represent trade-offs made based on specific constraints and requirements. Without documenting the rationale (why certain options were chosen over others), future maintainers may misunderstand the architecture or make changes that violate original assumptions."
        },
        {
          "question": "Which quality attribute trade-off is most commonly encountered when implementing extensive caching strategies?",
          "options": [
            "Security vs Usability",
            "Performance vs Data Consistency",
            "Portability vs Functionality",
            "Reliability vs Cost"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Caching improves performance (response time, throughput) but introduces complexity around cache invalidation and data consistency, potentially leading to stale data being served."
        },
        {
          "question": "What distinguishes a Domain Model from a Design Model?",
          "options": [
            "Domain Models use UML while Design Models use pseudocode",
            "Domain Models describe business concepts while Design Models describe technical implementation",
            "Domain Models are created by developers while Design Models are created by business analysts",
            "Domain Models focus on performance while Design Models focus on functionality"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A Domain Model captures business concepts, relationships, and rules in business language, independent of technology. A Design Model translates these into technical components, services, and implementation structures."
        },
        {
          "question": "Why is it particularly challenging to validate architectural decisions early in a project lifecycle?",
          "options": [
            "Stakeholders are unavailable for consultation early on",
            "Many decisions cannot be fully tested until parts of the system are built",
            "Architects lack sufficient information to make any decisions early on",
            "Early validation requires complete system specification"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions involve system-wide concerns that often depend on interactions between components. These interactions and their consequences may only become apparent when significant portions of the system are implemented and integrated."
        },
        {
          "question": "Which of the following is a key benefit of using architectural patterns?",
          "options": [
            "They eliminate the need for custom design work",
            "They provide proven solutions with known engineering trade-offs",
            "They guarantee optimal performance for any application",
            "They automatically generate implementation code"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural patterns encode proven solutions to common problems, along with their known benefits and trade-offs. This allows architects to leverage collective experience rather than inventing solutions from scratch."
        },
        {
          "question": "What role does a 'marketeecture' play in the architectural process?",
          "options": [
            "It serves as the final technical specification for developers",
            "It facilitates stakeholder communication and high-level understanding",
            "It replaces the need for detailed architectural documentation",
            "It provides performance benchmarks for the system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A marketeecture is a simplified, high-level visualization that helps non-technical stakeholders understand the system's value proposition and basic structure, facilitating discussion and alignment."
        },
        {
          "question": "Which quality attribute would be MOST directly improved by implementing an API-first design approach?",
          "options": [
            "Reliability",
            "Compatibility",
            "Security",
            "Portability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "API-first design, with stable contracts and versioning strategies, directly improves compatibility by ensuring clear, consistent interfaces for system interaction and data exchange."
        },
        {
          "question": "What is the primary purpose of hierarchical decomposition in architectural description?",
          "options": [
            "To hide complexity by revealing details only at appropriate abstraction levels",
            "To create more documentation than necessary",
            "To demonstrate all possible implementation paths",
            "To eliminate the need for multiple architectural views"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Hierarchical decomposition allows architects to manage complexity by presenting the architecture at different levels of detail. High-level views show major components and relationships, while lower levels reveal internal structures only when necessary."
        },
        {
          "question": "Which architectural view would be MOST useful for infrastructure teams planning server deployment?",
          "options": [
            "Logical View",
            "Process View",
            "Physical View",
            "Development View"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "The Physical View shows how software components are mapped to hardware resources, which is essential for infrastructure teams responsible for deployment, scaling, and hardware provisioning."
        },
        {
          "question": "What distinguishes responsibility-driven design from other component identification approaches?",
          "options": [
            "It focuses on assigning specific tasks and behaviors to components",
            "It prioritizes minimizing the number of components above all else",
            "It requires components to be implemented in object-oriented languages only",
            "It emphasizes data structures over component behavior"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Responsibility-driven design focuses on what each component should be responsible for—what tasks it performs and what behaviors it exhibits—which helps create cohesive, well-defined components with clear purposes."
        },
        {
          "question": "Which statement BEST describes the relationship between functional requirements and quality attributes?",
          "options": [
            "Functional requirements are more important than quality attributes",
            "Quality attributes constrain how functional requirements are implemented",
            "They are independent concerns that can be addressed separately",
            "Quality attributes are only relevant after functional requirements are satisfied"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Quality attributes (performance, security, etc.) dictate constraints on how functional requirements are implemented. For example, a 'place order' function must be implemented securely, performantly, and reliably."
        },
        {
          "question": "What is the primary value of creating an Informational Model separate from a Domain Model?",
          "options": [
            "It focuses purely on data structures independently of business meaning",
            "It serves as a technical database schema for implementation",
            "It replaces the need for database administrators",
            "It ensures all business rules are encoded in the data layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "An Informational Model focuses on the structure, relationships, and integrity of data itself, separate from the business semantics captured in the Domain Model. This separation allows clearer thinking about data design."
        },
        {
          "question": "Which architectural decision would MOST significantly impact system portability?",
          "options": [
            "Choosing a specific cloud provider's proprietary services",
            "Implementing comprehensive error logging",
            "Using design patterns in the codebase",
            "Creating detailed API documentation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Portability refers to the ease of moving the system between environments. Vendor lock-in through proprietary services severely reduces portability, while containerization and abstraction layers enhance it."
        },
        {
          "question": "What is the fundamental purpose of architectural validation?",
          "options": [
            "To ensure the architecture will satisfy quality attributes before major implementation",
            "To eliminate all risks from the development process",
            "To create perfect documentation for all stakeholders",
            "To guarantee the project will be delivered on time"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Architectural validation techniques (prototyping, analysis, simulation) aim to verify that the chosen architecture will meet critical quality requirements before substantial resources are committed to implementation."
        },
        {
          "question": "Which quality attribute is MOST directly addressed by implementing authentication, authorization, and encryption?",
          "options": [
            "Reliability",
            "Security",
            "Usability",
            "Maintainability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "These are core security mechanisms that address confidentiality (encryption), authenticity (authentication), and authorization (access control)—all sub-characteristics of Security in ISO 25010."
        },
        {
          "question": "What is the key insight behind using metrics for quality attributes?",
          "options": [
            "Metrics make abstract quality attributes measurable and comparable",
            "Metrics eliminate the need for architectural expertise",
            "All quality attributes can be reduced to a single metric",
            "Metrics are only useful for performance-related attributes"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Metrics transform vague quality goals (e.g., 'good performance') into measurable targets (e.g., '95th percentile response time < 200ms'), enabling objective evaluation, comparison, and trade-off analysis."
        },
        {
          "question": "Which scenario BEST illustrates a business constraint (as opposed to a technical constraint)?",
          "options": [
            "The application must use Java because the team only has Java expertise",
            "The database must run on Linux for security reasons",
            "The system must integrate with a specific partner's API to access their customer base",
            "The server must have at least 16GB RAM for adequate performance"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Business constraints arise from commercial, strategic, or operational business decisions rather than technical limitations. Integration for market access is a business-driven constraint."
        },
        {
          "question": "What is the primary danger of treating quality attributes as afterthoughts in architecture?",
          "options": [
            "They can become impossible or extremely costly to add later",
            "They only affect non-critical parts of the system",
            "They are easily retrofitted into any existing architecture",
            "They primarily impact only the user interface layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes like scalability, security, and maintainability often require fundamental architectural decisions. Retrofitting them later can require major rework, if it's possible at all."
        },
        {
          "question": "Which architectural style would be MOST appropriate for a system requiring independent scalability of different functional areas?",
          "options": [
            "Monolithic Architecture",
            "Layered Architecture",
            "Microservices Architecture",
            "Client-Server Architecture"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Microservices allow individual services to be scaled independently based on their specific load requirements, unlike monolithic architectures where the entire application scales together."
        },
        {
          "question": "What is the key characteristic of the Process View in architectural modeling?",
          "options": [
            "It focuses on concurrency, communication, and runtime behavior",
            "It shows the mapping of software to hardware resources",
            "It describes the static structure using class-like elements",
            "It organizes code in development environments"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Process View addresses runtime concerns: how components execute (threads, processes), how they communicate (synchronously/asynchronously), and how they handle concurrency."
        },
        {
          "question": "Which practice would MOST improve system maintainability?",
          "options": [
            "Implementing tight coupling between components for simplicity",
            "Creating clear component boundaries with low coupling and high cohesion",
            "Using the fewest possible components regardless of responsibility",
            "Writing all code in a single programming language"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Maintainability depends on how easily the system can be modified. Clear boundaries with low coupling (minimal dependencies) and high cohesion (related functionality together) make changes more localized and predictable."
        },
        {
          "question": "What is the fundamental purpose of stakeholder requirements analysis?",
          "options": [
            "To create technical specifications for developers",
            "To align development with business goals and user needs before building",
            "To eliminate all communication with non-technical stakeholders",
            "To produce marketing materials for the product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stakeholder requirements capture the needs, expectations, and constraints of all parties involved. This alignment ensures the resulting system delivers real value and meets actual needs."
        },
        {
          "question": "Which architectural consideration is MOST critical when designing for high availability?",
          "options": [
            "Minimizing the number of external dependencies",
            "Eliminating all single points of failure",
            "Using the fastest available hardware",
            "Implementing the most sophisticated algorithms"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "High availability requires that no single component failure can bring down the entire system. This typically involves redundancy, failover mechanisms, and distributed architectures."
        },
        {
          "question": "What distinguishes explicit requirements from implicit requirements?",
          "options": [
            "Explicit requirements are documented while implicit ones are assumed",
            "Explicit requirements are technical while implicit ones are business-related",
            "Explicit requirements change frequently while implicit ones are stable",
            "Explicit requirements are optional while implicit ones are mandatory"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Explicit requirements are formally stated and documented. Implicit requirements are unstated assumptions or expectations that stakeholders believe are obvious but may not be captured formally, leading to potential misunderstandings."
        },
        {
          "question": "Which factor MOST influences the choice between synchronous and asynchronous communication between components?",
          "options": [
            "The programming language used for implementation",
            "Performance requirements and coupling tolerance",
            "The preferences of the development team",
            "The cost of development tools"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Synchronous communication (tight coupling, simpler) vs asynchronous (looser coupling, more complex) involves trade-offs between performance, reliability, and system complexity that must align with quality requirements."
        },
        {
          "question": "What is the primary purpose of architectural prototyping?",
          "options": [
            "To create a fully functional version of the system",
            "To validate technical risks and architectural hypotheses",
            "To replace the need for requirements analysis",
            "To serve as the final production system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural prototypes focus on validating specific high-risk aspects of the architecture (performance, integration, etc.) rather than building complete functionality."
        },
        {
          "question": "Which quality attribute would be MOST affected by implementing a Backend-for-Frontend (BFF) pattern?",
          "options": ["Security", "Usability", "Portability", "Reliability"],
          "correctOption": 1,
          "points": 10,
          "explanation": "BFF creates separate backend services tailored to specific frontend needs, improving usability by optimizing data delivery and interactions for each user interface context."
        },
        {
          "question": "What is the key benefit of using Commercial Off-The-Shelf (COTS) technologies that implement architectural patterns?",
          "options": [
            "They eliminate all customization needs",
            "They provide proven implementations of architectural approaches",
            "They guarantee the best performance for any use case",
            "They reduce the need for architectural design altogether"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "COTS technologies (like message brokers, application servers) provide ready-made, tested implementations of common architectural patterns, reducing development risk and effort."
        },
        {
          "question": "Which practice would MOST improve system analysability (ease of understanding the system)?",
          "options": [
            "Using short, cryptic variable names to save space",
            "Creating complex, deeply nested component hierarchies",
            "Implementing clear module decomposition with meaningful names",
            "Minimizing documentation to avoid outdated information"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Analysability, a sub-characteristic of Maintainability, is improved by clear organization, meaningful naming, and logical decomposition that helps developers understand system structure and behavior."
        },
        {
          "question": "What is the fundamental challenge in balancing security and usability?",
          "options": [
            "They are mutually exclusive and cannot coexist",
            "Increased security measures often create user friction",
            "Usability always compromises security effectiveness",
            "Security is only relevant for administrative users"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Strong security (multi-factor authentication, frequent re-authentication, complex passwords) can hinder usability. Architects must find balanced solutions that provide adequate security without excessive user burden."
        },
        {
          "question": "Which architectural decision would MOST directly address scalability concerns?",
          "options": [
            "Implementing comprehensive audit logging",
            "Using stateless services with horizontal scaling",
            "Choosing a specific programming language",
            "Creating detailed user documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stateless services can be easily replicated across multiple servers (horizontal scaling), allowing the system to handle increased load by adding more instances rather than upgrading single servers."
        },
        {
          "question": "What is the primary value of the ISO/IEC 25010 quality model?",
          "options": [
            "It provides a complete checklist of all possible system features",
            "It offers a standardized vocabulary for discussing system quality",
            "It eliminates the need for architectural decision-making",
            "It guarantees specific performance levels for any system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ISO 25010 provides a shared, standardized framework for discussing, specifying, and evaluating software quality characteristics, enabling clearer communication between stakeholders."
        },
        {
          "question": "Which factor is MOST critical when evaluating architectural alternatives?",
          "options": [
            "The popularity of each alternative in the industry",
            "How well each addresses the specific quality attribute priorities",
            "The complexity of implementation for each alternative",
            "The personal preferences of the architect"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions should be driven by how well alternatives satisfy the prioritized quality attributes for the specific system context, not by general popularity or personal preference."
        },
        {
          "question": "What is the key insight about system failures according to the quality attributes lecture?",
          "options": [
            "Most failures are caused by missing features rather than quality issues",
            "Quality issues cause more system failures than missing functionality",
            "Failures are evenly distributed between functional and quality issues",
            "Failures are primarily caused by hardware rather than software issues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "The lecture emphasizes that systems with identical features can have very different success based on quality attributes, and that quality issues (performance, reliability, security) often cause more problems than missing features."
        },
        {
          "question": "Which architectural approach would BEST support fault tolerance?",
          "options": [
            "Implementing circuit breakers and graceful degradation",
            "Using the fastest available algorithms",
            "Minimizing the number of external dependencies",
            "Creating comprehensive user manuals"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Circuit breakers prevent cascading failures by isolating failing components, while graceful degradation allows the system to continue providing reduced functionality during partial failures."
        },
        {
          "question": "What is the primary risk of over-optimizing for a single quality attribute?",
          "options": [
            "It may negatively impact other important quality attributes",
            "It guarantees optimal system performance overall",
            "It simplifies the architectural decision process",
            "It eliminates the need for trade-off analysis"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes often involve trade-offs. Over-optimizing one (e.g., extreme performance) may severely degrade others (e.g., maintainability, security, or cost)."
        },
        {
          "question": "Which practice would MOST improve system testability?",
          "options": [
            "Creating tightly coupled components for simplicity",
            "Implementing complex, interdependent business logic",
            "Designing components with clear interfaces and minimal dependencies",
            "Using global variables for data sharing between components"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Testability is improved when components have clear boundaries, well-defined interfaces, and minimal external dependencies, allowing them to be tested in isolation with appropriate test doubles."
        },
        {
          "question": "What distinguishes the Development View from other architectural views?",
          "options": [
            "It focuses on how code is organized in development environments",
            "It shows runtime process interactions and communications",
            "It maps software components to physical hardware",
            "It describes business concepts and their relationships"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Development View addresses development-time concerns: source code organization, module structure, build dependencies, and configuration management—how developers work with the codebase."
        },
        {
          "question": "Which factor is MOST important when selecting architectural tactics for quality attributes?",
          "options": [
            "The tactics' popularity in recent blog posts",
            "How well tactics address specific, measurable quality goals",
            "The simplicity of implementing each tactic",
            "Whether the team has previously used the tactics"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural tactics should be chosen based on their effectiveness in achieving specific, measurable quality attribute targets identified for the system, not general popularity or familiarity."
        },
        {
          "question": "What is the fundamental purpose of architecture validation and verification?",
          "options": [
            "To ensure the architecture meets stakeholder needs and is correctly implemented",
            "To eliminate all defects from the final system",
            "To create perfect architectural documentation",
            "To guarantee the project will finish early"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Validation ensures the architecture meets stakeholder requirements (building the right thing). Verification ensures the implementation correctly follows the architecture (building it right)."
        },
        {
          "question": "Which architectural concern would be MOST relevant for a system requiring frequent business rule changes?",
          "options": [
            "Maximizing raw computational performance",
            "Minimizing hardware resource usage",
            "Ensuring high modifiability and low change cost",
            "Optimizing for minimal development time"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Frequent business rule changes demand high modifiability—the ease of making changes. This requires architectural decisions that localize business logic and minimize ripple effects from changes."
        },
        {
          "question": "What is the key characteristic of a well-defined component interface?",
          "options": [
            "It exposes all internal implementation details for flexibility",
            "It provides a clear, stable contract while hiding implementation",
            "It changes frequently to accommodate evolving needs",
            "It maximizes the number of parameters for completeness"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Good interfaces provide stable, well-documented contracts that specify what services are provided while hiding how they're implemented, enabling independent evolution of components."
        },
        {
          "question": "Which quality attribute would be MOST impacted by implementing a comprehensive monitoring and alerting system?",
          "options": [
            "Functional Suitability",
            "Reliability (specifically recoverability)",
            "Portability",
            "Compatibility"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Monitoring and alerting directly support reliability by enabling faster detection of issues (improving MTTR - Mean Time To Recovery) and providing data for root cause analysis."
        },
        {
          "question": "What is the primary value of documenting architectural decisions as Architecture Decision Records (ADRs)?",
          "options": [
            "They eliminate the need for other architectural documentation",
            "They capture the rationale and context behind design choices",
            "They serve as detailed implementation specifications",
            "They replace the need for code comments"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ADRs capture not just what was decided, but why—the context, alternatives considered, trade-offs, and consequences. This preserves crucial reasoning that would otherwise be lost."
        },
        {
          "question": "Which architectural consideration is MOST critical for systems with stringent data privacy requirements?",
          "options": [
            "Maximizing development velocity",
            "Ensuring data encryption both in transit and at rest",
            "Using the simplest possible architecture",
            "Minimizing the number of database tables"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Data privacy requires strong security measures, with encryption being fundamental for protecting sensitive data both during transmission and while stored."
        }
      ]
    },
    {
      "id": "Infobez variant 1",
      "name": "Infobez variant 1",
      "description": "A quiz on infobez",
      "questions": [
        {
          "question": "A context diagram shows the system:",
          "options": [
            "As a single unit",
            "With detailed APIs",
            "As multiple components",
            "With internal services"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "A context diagram represents the system as a single black box and shows its interactions with external actors, without revealing internal details."
        },
        {
          "question": "Performance efficiency is concerned with:",
          "options": [
            "System correctness",
            "User satisfaction",
            "Resource usage relative to performance",
            "Visual design"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Performance efficiency measures how well the system uses resources (CPU, memory, network) relative to its performance metrics like response time and throughput."
        },
        {
          "question": "Stakeholders include:",
          "options": [
            "Only developers",
            "Individuals or groups impacted by the system",
            "Only project sponsors",
            "Only end users"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stakeholders are any individuals or groups impacted by or involved in the system, including clients, users, developers, managers, and sponsors."
        },
        {
          "question": "The need for multiple models follows which principle?",
          "options": [
            "Separation of Concerns",
            "Inheritance",
            "Single Responsibility",
            "Encapsulation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Different stakeholders have different concerns, so multiple models address each concern separately, following the Separation of Concerns principle."
        },
        {
          "question": "Technical constraints are usually:",
          "options": ["Optional", "Ignored", "Non-negotiable", "Negotiable"],
          "correctOption": 2,
          "points": 10,
          "explanation": "Technical constraints (like mandated technologies or platforms) are typically non-negotiable requirements that must be adhered to."
        },
        {
          "question": "Usability measures:",
          "options": [
            "Security level",
            "Hardware consumption",
            "Code quality",
            "Ease and efficiency of system usage"
          ],
          "correctOption": 3,
          "points": 10,
          "explanation": "Usability measures how easily and efficiently users can achieve their goals when using the system, including learnability and operability."
        },
        {
          "question": "Compatibility focuses on the system's ability to:",
          "options": [
            "Scale horizontally",
            "Interact with other systems",
            "Recover from failure",
            "Protect data"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Compatibility addresses the system's ability to interact and exchange data with other systems or components through co-existence and interoperability."
        },
        {
          "question": "Security ensures all EXCEPT:",
          "options": [
            "Authenticity",
            "Confidentiality",
            "Integrity",
            "Performance"
          ],
          "correctOption": 3,
          "points": 10,
          "explanation": "Security ensures authenticity, confidentiality, integrity, and accountability, but not performance, which is a separate quality attribute."
        },
        {
          "question": "Responsibility-driven design is mainly used to:",
          "options": [
            "Write test cases",
            "Manage deployment",
            "Optimize databases",
            "Define key components and their roles"
          ],
          "correctOption": 3,
          "points": 10,
          "explanation": "Responsibility-driven design helps identify and define key components by assigning specific responsibilities and roles to each."
        },
        {
          "question": "System models are commonly represented using:",
          "options": [
            "Source repositories",
            "Flowcharts only",
            "UML diagrams",
            "Spreadsheets"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "System models are often visualized using UML (Unified Modeling Language) diagrams, which provide standardized notations for architectural modeling."
        },
        {
          "question": "Text-based requirement lists often include:",
          "options": [
            "Only diagrams",
            "Random descriptions",
            "Unique IDs for traceability",
            "Source code"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Text-based requirement lists typically assign unique identifiers to each requirement for traceability throughout the development lifecycle."
        },
        {
          "question": "A common communication pattern mentioned is:",
          "options": [
            "Peer-to-peer mining",
            "Batch processing",
            "Client-server synchronous request-reply",
            "File-based polling"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "The client-server synchronous request-reply pattern is fundamental where a client sends a request and waits for a reply from the server."
        },
        {
          "question": "Use case diagrams are mainly used to:",
          "options": [
            "Store data",
            "Define hardware layout",
            "Control versioning",
            "Capture functionality"
          ],
          "correctOption": 3,
          "points": 10,
          "explanation": "Use case diagrams are used to capture and visualize functional requirements and interactions between actors and the system."
        },
        {
          "question": "Reliability refers to the system's ability to:",
          "options": [
            "Perform correctly over time",
            "Run on different platforms",
            "Be easy to modify",
            "Protect sensitive data"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Reliability is the ability of the system to perform correctly and consistently over time under specified conditions."
        },
        {
          "question": "Process requirements relate to:",
          "options": [
            "System output",
            "User interface design",
            "Methods and tools used during development",
            "Functional behavior"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Process requirements define the methods, tools, and constraints used during the development process, not the product itself."
        },
        {
          "question": "Explicit requirements are:",
          "options": [
            "Clearly documented",
            "Assumed by stakeholders",
            "Always technical",
            "Not documented"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Explicit requirements are those that are clearly and formally documented, as opposed to implicit ones that are assumed."
        },
        {
          "question": "The informational model focuses primarily on:",
          "options": [
            "Data and its structure",
            "Business meaning",
            "Technical services",
            "User interaction"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The informational model focuses on the structure, relationships, and constraints of data, independent of business meaning or technical implementation."
        },
        {
          "question": "The primary criterion for 'sensible' architectural partitioning is:",
          "options": [
            "Team preferences",
            "Meeting specific requirements and constraints",
            "Following industry trends",
            "Maximizing component count"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural partitioning must be driven by the specific requirements and constraints of the application, not by trends or preferences."
        },
        {
          "question": "Quality attributes and system architecture are related such that:",
          "options": [
            "Architecture exists primarily to satisfy quality attributes",
            "Quality attributes are secondary to functional requirements",
            "Quality attributes only affect the UI",
            "Each quality attribute can be maximized independently"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Architecture fundamentally exists to satisfy quality attributes (performance, security, etc.) which define how well the system works."
        },
        {
          "question": "Non-functional requirements differ from quality attributes in that:",
          "options": [
            "Non-functional requirements are technical, quality attributes are business-oriented",
            "Non-functional requirements are vague, quality attributes are measurable",
            "They are the same",
            "Non-functional requirements apply to process, quality attributes to product"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Non-functional requirements are often informal statements, while quality attributes are measurable characteristics that drive architectural decisions."
        },
        {
          "question": "Which architectural tactic most directly addresses reliability?",
          "options": [
            "Comprehensive logging",
            "Redundancy and failover",
            "Latest programming language",
            "Detailed documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Reliability focuses on availability and fault tolerance, which are directly addressed by redundancy and failover mechanisms."
        },
        {
          "question": "The purpose of multiple architectural models is to:",
          "options": [
            "Increase documentation workload",
            "Address different stakeholder concerns",
            "Demonstrate architect versatility",
            "Provide backup models"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Different stakeholders have different concerns, so multiple models are needed to address each concern effectively (Separation of Concerns)."
        },
        {
          "question": "Choosing a monolithic architecture over microservices most compromises:",
          "options": [
            "Functional Suitability",
            "Performance Efficiency",
            "Scalability and Maintainability",
            "Security"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Monolithic architectures typically compromise scalability and maintainability compared to microservices, which allow independent scaling and deployment."
        },
        {
          "question": "Which element should never appear in a Context Diagram?",
          "options": [
            "External user roles",
            "Interaction flows",
            "Internal service components",
            "System boundary"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "A Context Diagram shows the system as a single black box; showing internal components violates its purpose."
        },
        {
          "question": "The primary risk of not documenting architectural decisions is:",
          "options": [
            "Increased initial cost",
            "Loss of rationale for future maintainers",
            "Immediate system failure",
            "Violation of coding standards"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Without documented rationale, future maintainers may misunderstand the architecture or make changes that violate original assumptions."
        },
        {
          "question": "Extensive caching strategies commonly involve a trade-off between:",
          "options": [
            "Security and Usability",
            "Performance and Data Consistency",
            "Portability and Functionality",
            "Reliability and Cost"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Caching improves performance but introduces complexity around cache invalidation and data consistency, potentially leading to stale data."
        },
        {
          "question": "A Domain Model differs from a Design Model in that:",
          "options": [
            "Domain Models use UML, Design Models use pseudocode",
            "Domain Models describe business concepts, Design Models describe technical implementation",
            "Domain Models are by developers, Design Models by business analysts",
            "Domain Models focus on performance, Design Models on functionality"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A Domain Model captures business concepts and relationships, while a Design Model translates these into technical components and implementation structures."
        },
        {
          "question": "Validating architectural decisions early is challenging because:",
          "options": [
            "Stakeholders are unavailable",
            "Decisions cannot be fully tested until parts are built",
            "Architects lack information",
            "Early validation requires complete specification"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions involve system-wide concerns that often depend on component interactions, which may only become apparent during implementation."
        },
        {
          "question": "A key benefit of architectural patterns is:",
          "options": [
            "Eliminating custom design",
            "Providing proven solutions with known trade-offs",
            "Guaranteeing optimal performance",
            "Automatic code generation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural patterns provide proven solutions to common problems with known engineering trade-offs, reducing risk and effort."
        },
        {
          "question": "A 'marketeecture' is primarily used to:",
          "options": [
            "Serve as technical specification",
            "Facilitate stakeholder communication",
            "Replace detailed documentation",
            "Provide performance benchmarks"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "A marketeecture is a simplified, high-level visualization that helps non-technical stakeholders understand the system's value and structure."
        },
        {
          "question": "API-first design most directly improves:",
          "options": [
            "Reliability",
            "Compatibility",
            "Security",
            "Portability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "API-first design, with stable contracts and versioning, directly improves compatibility by ensuring clear, consistent interfaces for system interaction."
        },
        {
          "question": "Hierarchical decomposition is used to:",
          "options": [
            "Hide complexity by revealing details at appropriate levels",
            "Create more documentation",
            "Demonstrate all implementation paths",
            "Eliminate the need for multiple views"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Hierarchical decomposition manages complexity by presenting architecture at different detail levels, hiding unnecessary details at higher levels."
        },
        {
          "question": "Infrastructure teams would find which architectural view most useful?",
          "options": [
            "Logical View",
            "Process View",
            "Physical View",
            "Development View"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "The Physical View shows how software components map to hardware resources, essential for deployment, scaling, and hardware provisioning."
        },
        {
          "question": "Responsibility-driven design focuses on:",
          "options": [
            "Assigning specific tasks and behaviors to components",
            "Minimizing the number of components",
            "Requiring object-oriented languages",
            "Emphasizing data structures"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Responsibility-driven design identifies components based on what tasks they perform and what behaviors they exhibit."
        },
        {
          "question": "Functional requirements and quality attributes are related such that:",
          "options": [
            "Functional requirements are more important",
            "Quality attributes constrain how functional requirements are implemented",
            "They are independent",
            "Quality attributes are only relevant after functional requirements"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Quality attributes dictate constraints on how functional requirements are implemented (e.g., securely, performantly, reliably)."
        },
        {
          "question": "An Informational Model is valuable because it focuses on:",
          "options": [
            "Data structures independently of business meaning",
            "Technical database schema",
            "Eliminating database administrators",
            "Encoding business rules in the data layer"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "An Informational Model focuses purely on data structures and relationships, separate from business semantics or implementation."
        },
        {
          "question": "System portability is most impacted by:",
          "options": [
            "Choosing proprietary cloud services",
            "Implementing error logging",
            "Using design patterns",
            "Creating API documentation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Vendor lock-in through proprietary services severely reduces portability, while containerization and abstraction layers enhance it."
        },
        {
          "question": "Architectural validation aims to:",
          "options": [
            "Ensure the architecture satisfies quality attributes before implementation",
            "Eliminate all risks",
            "Create perfect documentation",
            "Guarantee on-time delivery"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Architectural validation verifies that the chosen architecture will meet critical quality requirements before substantial implementation."
        },
        {
          "question": "Authentication, authorization, and encryption most directly address:",
          "options": [
            "Reliability",
            "Security",
            "Usability",
            "Maintainability"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "These are core security mechanisms addressing confidentiality (encryption), authenticity (authentication), and authorization."
        },
        {
          "question": "Metrics for quality attributes are important because they:",
          "options": [
            "Make abstract qualities measurable and comparable",
            "Eliminate the need for architectural expertise",
            "Reduce all qualities to a single metric",
            "Are only useful for performance"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Metrics transform vague quality goals into measurable targets, enabling objective evaluation and trade-off analysis."
        },
        {
          "question": "A business constraint is best illustrated by:",
          "options": [
            "Must use Java due to team expertise",
            "Database must run on Linux for security",
            "Must integrate with a partner's API for market access",
            "Server must have 16GB RAM for performance"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Business constraints arise from commercial or strategic decisions rather than technical limitations."
        },
        {
          "question": "Treating quality attributes as afterthoughts is dangerous because:",
          "options": [
            "They become impossible or costly to add later",
            "They only affect non-critical parts",
            "They are easily retrofitted",
            "They only affect the UI"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes often require fundamental architectural decisions; retrofitting them later can require major rework."
        },
        {
          "question": "Independent scalability of functional areas is best supported by:",
          "options": [
            "Monolithic Architecture",
            "Layered Architecture",
            "Microservices Architecture",
            "Client-Server Architecture"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Microservices allow individual services to scale independently based on their specific load requirements."
        },
        {
          "question": "The Process View focuses on:",
          "options": [
            "Concurrency, communication, and runtime behavior",
            "Mapping software to hardware",
            "Static structure using class-like elements",
            "Code organization in development"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Process View addresses runtime concerns: how components execute, communicate, and handle concurrency."
        },
        {
          "question": "System maintainability is most improved by:",
          "options": [
            "Tight coupling for simplicity",
            "Clear boundaries with low coupling and high cohesion",
            "Fewest possible components",
            "Single programming language"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Clear boundaries with low coupling (minimal dependencies) and high cohesion (related functionality together) make changes more localized."
        },
        {
          "question": "Stakeholder requirements analysis aims to:",
          "options": [
            "Create technical specifications",
            "Align development with business goals and user needs",
            "Eliminate communication with non-technical stakeholders",
            "Produce marketing materials"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stakeholder requirements capture the needs, expectations, and constraints to ensure the system delivers real value."
        },
        {
          "question": "Designing for high availability requires:",
          "options": [
            "Minimizing external dependencies",
            "Eliminating single points of failure",
            "Fastest hardware",
            "Most sophisticated algorithms"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "High availability requires that no single component failure can bring down the entire system, typically through redundancy."
        },
        {
          "question": "The choice between synchronous and asynchronous communication is most influenced by:",
          "options": [
            "Programming language",
            "Performance requirements and coupling tolerance",
            "Team preferences",
            "Tool cost"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Synchronous vs asynchronous involves trade-offs between performance, reliability, and system complexity aligned with quality requirements."
        },
        {
          "question": "Architectural prototyping is used to:",
          "options": [
            "Create a fully functional system",
            "Validate technical risks and architectural hypotheses",
            "Replace requirements analysis",
            "Serve as the final production system"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural prototypes validate specific high-risk aspects of the architecture rather than building complete functionality."
        },
        {
          "question": "The Backend-for-Frontend (BFF) pattern most affects:",
          "options": ["Security", "Usability", "Portability", "Reliability"],
          "correctOption": 1,
          "points": 10,
          "explanation": "BFF creates separate backend services tailored to specific frontend needs, improving usability by optimizing data delivery."
        },
        {
          "question": "COTS technologies that implement architectural patterns provide:",
          "options": [
            "Elimination of customization",
            "Proven implementations of architectural approaches",
            "Guaranteed best performance",
            "No need for architectural design"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "COTS technologies provide ready-made, tested implementations of common patterns, reducing development risk and effort."
        },
        {
          "question": "System analysability is most improved by:",
          "options": [
            "Cryptic variable names",
            "Complex nested hierarchies",
            "Clear module decomposition with meaningful names",
            "Minimizing documentation"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Analysability is improved by clear organization, meaningful naming, and logical decomposition that aids understanding."
        },
        {
          "question": "Balancing security and usability is challenging because:",
          "options": [
            "They are mutually exclusive",
            "Increased security often creates user friction",
            "Usability always compromises security",
            "Security is only for administrative users"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Strong security measures (multi-factor auth, complex passwords) can hinder usability, requiring balanced solutions."
        },
        {
          "question": "Scalability concerns are most directly addressed by:",
          "options": [
            "Comprehensive audit logging",
            "Stateless services with horizontal scaling",
            "Specific programming language",
            "Detailed user documentation"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Stateless services can be easily replicated across multiple servers, allowing horizontal scaling to handle increased load."
        },
        {
          "question": "The ISO/IEC 25010 quality model provides:",
          "options": [
            "A complete feature checklist",
            "Standardized vocabulary for discussing system quality",
            "Elimination of architectural decisions",
            "Guaranteed performance levels"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "ISO 25010 provides a shared, standardized framework for discussing, specifying, and evaluating software quality characteristics."
        },
        {
          "question": "When evaluating architectural alternatives, the most critical factor is:",
          "options": [
            "Industry popularity",
            "How well each addresses prioritized quality attributes",
            "Implementation complexity",
            "Architect's preference"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural decisions should be driven by how well alternatives satisfy the prioritized quality attributes for the specific context."
        },
        {
          "question": "Regarding system failures, the key insight is:",
          "options": [
            "Most are caused by missing features",
            "Quality issues cause more failures than missing functionality",
            "Failures are evenly distributed",
            "Failures are primarily hardware issues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Systems with identical features can have very different success based on quality attributes, and quality issues often cause more problems."
        },
        {
          "question": "Fault tolerance is best supported by:",
          "options": [
            "Circuit breakers and graceful degradation",
            "Fastest algorithms",
            "Minimizing external dependencies",
            "Comprehensive user manuals"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Circuit breakers prevent cascading failures by isolating failing components, while graceful degradation allows continued reduced functionality."
        },
        {
          "question": "Over-optimizing for a single quality attribute risks:",
          "options": [
            "Negatively impacting other quality attributes",
            "Guaranteeing optimal system performance",
            "Simplifying architectural decisions",
            "Eliminating trade-off analysis"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Quality attributes involve trade-offs; over-optimizing one may severely degrade others (e.g., extreme performance vs maintainability)."
        },
        {
          "question": "System testability is most improved by:",
          "options": [
            "Tight coupling for simplicity",
            "Complex interdependent business logic",
            "Clear interfaces with minimal dependencies",
            "Global variables for data sharing"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Testability is improved when components have clear boundaries, well-defined interfaces, and minimal external dependencies."
        },
        {
          "question": "The Development View focuses on:",
          "options": [
            "Code organization in development environments",
            "Runtime process interactions",
            "Mapping software to hardware",
            "Business concepts and relationships"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "The Development View addresses development-time concerns: source code organization, module structure, build dependencies."
        },
        {
          "question": "Selecting architectural tactics for quality attributes should be based on:",
          "options": [
            "Popularity in blogs",
            "Effectiveness in achieving measurable quality goals",
            "Implementation simplicity",
            "Team familiarity"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Architectural tactics should be chosen based on effectiveness in achieving specific, measurable quality attribute targets."
        },
        {
          "question": "Architecture validation and verification ensure:",
          "options": [
            "The architecture meets stakeholder needs and is correctly implemented",
            "All defects are eliminated",
            "Perfect documentation",
            "Project finishes early"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Validation ensures the architecture meets requirements (right thing). Verification ensures correct implementation (built right)."
        },
        {
          "question": "Frequent business rule changes require high:",
          "options": [
            "Computational performance",
            "Resource usage minimization",
            "Modifiability and low change cost",
            "Minimal development time"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Frequent changes demand high modifiability—localized business logic and minimal ripple effects from changes."
        },
        {
          "question": "A well-defined component interface provides:",
          "options": [
            "Exposure of all internal details",
            "A clear, stable contract while hiding implementation",
            "Frequent changes",
            "Many parameters for completeness"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Good interfaces provide stable, documented contracts specifying what services are provided while hiding implementation."
        },
        {
          "question": "A comprehensive monitoring and alerting system most impacts:",
          "options": [
            "Functional Suitability",
            "Reliability (specifically recoverability)",
            "Portability",
            "Compatibility"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Monitoring and alerting directly support reliability by enabling faster issue detection and providing data for root cause analysis."
        }
      ]
    },
    {
      "id": "Infobez variant 2",
      "name": "Infobez variant 2",
      "description": "A quiz on infobez",
      "questions": [
        {
          "question": "Which term describes information being actively handled by an application (e.g., in RAM or CPU during computation)?",
          "options": [
            "Data at rest",
            "Data in transit",
            "Data in process",
            "Archived data",
            "Cold data"
          ],
          "correctOption": 2,
          "points": 10,
          "explanation": "Data in process (or data in use) refers to data currently being processed by applications in memory or CPU. This is one of the three states of digital data (at rest, in transit, in process) that require different security protections."
        },
        {
          "question": "Which control best reduces the risk of unauthorized access if a laptop is lost?",
          "options": [
            "Disk encryption",
            "Disabling updates",
            "Using default admin accounts",
            "Turning off the firewall",
            "Sharing passwords"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Full disk encryption (FDE) protects data at rest by encrypting the entire storage drive. Even if a laptop is lost or stolen, the data remains inaccessible without the encryption key or password, preventing unauthorized access to sensitive information."
        },
        {
          "question": "Which concept refers to proving that a specific action was performed by a particular user and cannot be denied later?",
          "options": [
            "Availability",
            "Nonrepudiation",
            "Confidentiality",
            "Steganography",
            "Load balancing"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Nonrepudiation provides proof of the origin and integrity of data, ensuring that a party cannot deny having performed an action. This is typically achieved through digital signatures, audit trails, and logging mechanisms in secure systems."
        },
        {
          "question": "What is the main purpose of an Initialization Vector (IV) in many encryption modes?",
          "options": [
            "To replace the key",
            "To add randomness so identical plaintext blocks encrypt differently",
            "To compress the ciphertext",
            "To verify user identity",
            "To disable replay protection"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "An Initialization Vector is a random or pseudo-random value used to ensure that identical plaintext blocks produce different ciphertext blocks when encrypted. This prevents pattern recognition attacks and adds semantic security to encryption."
        },
        {
          "question": "Which of the following most directly provides confidentiality for a file stored on disk?",
          "options": [
            "Symmetric encryption (e.g., AES)",
            "Hashing (e.g., SHA-256)",
            "Encoding (Base64)",
            "Routing",
            "DHCP"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Symmetric encryption like AES (Advanced Encryption Standard) directly provides confidentiality by transforming plaintext into ciphertext using a secret key, ensuring that only authorized parties with the key can access the original data."
        },
        {
          "question": "Which statement about ACLs is correct?",
          "options": [
            "ACLs can be used to permit or deny traffic based on defined criteria",
            "ACLs automatically encrypt traffic",
            "ACLs replace routing protocols",
            "ACLs work only on end-user PCs",
            "ACLs are the same as backups"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Access Control Lists (ACLs) are rule-based security mechanisms that filter network traffic by permitting or denying packets based on criteria like source/destination IP addresses, ports, and protocols. They don't encrypt traffic or replace routing."
        },
        {
          "question": "A 'standard' IPv4 ACL in Cisco IOS typically filters traffic based on:",
          "options": [
            "Source IP address only",
            "Destination port only",
            "Application layer payload",
            "MAC address only",
            "Wireless SSID"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Standard ACLs in Cisco IOS (numbered 1-99, 1300-1999) filter based solely on source IP address. Extended ACLs (100-199, 2000-2699) can filter on source/destination IP, ports, protocols, and other criteria."
        },
        {
          "question": "When troubleshooting why traffic is blocked, which step is most relevant?",
          "options": [
            "Check ACL rule order and interface direction",
            "Increase screen brightness",
            "Disable routing",
            "Delete DNS records",
            "Turn off logging"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "ACL troubleshooting involves verifying rule order (first match applies), direction (inbound/outbound), interface application, and specific permit/deny statements. These factors determine which traffic is allowed or blocked."
        },
        {
          "question": "Which Linux command is commonly used to display the contents of a text file to the terminal?",
          "options": ["cat", "mv", "chmod", "grep -v", "sudoers"],
          "correctOption": 0,
          "points": 10,
          "explanation": "The 'cat' (concatenate) command reads files sequentially and writes their contents to standard output. It's one of the most basic and frequently used commands for viewing file contents in Linux/Unix systems."
        },
        {
          "question": "Which statement about OpenSSL usage is most accurate?",
          "options": [
            "OpenSSL can encrypt and decrypt data from the command line",
            "OpenSSL is only for routing configuration",
            "OpenSSL automatically guarantees integrity in all modes",
            "OpenSSL replaces access control",
            "OpenSSL is a file compression tool"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "OpenSSL is a robust, full-featured toolkit implementing SSL/TLS protocols and general-purpose cryptography. It provides command-line tools for encryption, decryption, certificate management, and cryptographic operations."
        },
        {
          "question": "What does the -d option indicate in many command-line encryption tools (including typical OpenSSL usage)?",
          "options": ["Decrypt", "Delete", "Download", "Duplicate", "Diagnose"],
          "correctOption": 0,
          "points": 10,
          "explanation": "In encryption tools like OpenSSL, the '-d' flag typically stands for 'decrypt,' instructing the tool to perform decryption rather than encryption. This convention is common across many cryptographic utilities."
        },
        {
          "question": "Which is the best description of Base64 output when encrypting a file?",
          "options": [
            "It makes ciphertext human-readable for transport, but does not add security",
            "It is stronger than AES",
            "It converts ciphertext into plaintext",
            "It disables passwords",
            "It guarantees integrity"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Base64 encoding converts binary data (like encrypted ciphertext) into ASCII text format, making it safe for transmission through text-based systems. It provides no cryptographic security—it's purely an encoding scheme."
        },
        {
          "question": "Which is a common reason to keep encrypted outputs ASCII-friendly?",
          "options": [
            "To safely copy/paste or transmit through text-only channels",
            "To reduce CPU usage to zero",
            "To disable authentication",
            "To increase Wi-Fi range",
            "To bypass permissions"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "ASCII-friendly formats (like Base64) allow encrypted data to be safely embedded in emails, web forms, configuration files, and other text-based systems without corruption from binary characters that might be misinterpreted."
        },
        {
          "question": "Which pair correctly matches purpose to tool?",
          "options": [
            "Encryption – confidentiality",
            "Encoding – confidentiality",
            "Hashing – confidentiality",
            "Routing – integrity",
            "DNS – nonrepudiation"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Encryption specifically provides confidentiality by making data unreadable without proper authorization. Hashing provides integrity, encoding enables compatibility, routing directs network traffic, and DNS resolves domain names—none provide confidentiality."
        },
        {
          "question": "What is the main security drawback of encryption without integrity checks (e.g., no MAC/authenticated mode)?",
          "options": [
            "Ciphertext could be modified without detection",
            "It uses too much disk space",
            "It prevents backups",
            "It cannot be decrypted",
            "It forces password reuse"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Encryption without integrity protection (like AES in ECB or CBC mode without HMAC) is vulnerable to tampering. Attackers can modify ciphertext, potentially altering the decrypted plaintext without the recipient detecting the changes."
        },
        {
          "question": "Which answer best describes why long passwords are harder to guess?",
          "options": [
            "They increase the search space (entropy)",
            "They always contain symbols",
            "They disable brute-force tools",
            "They remove the need for a key",
            "They reduce encryption strength"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Password length exponentially increases the possible combinations (entropy), making brute-force attacks computationally impractical. Each additional character multiplies the search space, significantly increasing the time required to guess the password."
        },
        {
          "question": "Which practice best helps prevent credential exposure across multiple services?",
          "options": [
            "Reuse the same password everywhere",
            "Use unique passwords per service",
            "Store passwords in plain text",
            "Disable two-factor authentication",
            "Share passwords with colleagues"
          ],
          "correctOption": 1,
          "points": 10,
          "explanation": "Using unique passwords for each service limits damage from credential stuffing attacks and data breaches. If one service is compromised, attackers cannot reuse those credentials to access other accounts (password reuse is a major security risk)."
        },
        {
          "question": "Which statement about /etc/passwd is generally correct?",
          "options": [
            "It contains user account info; hashes are stored elsewhere on modern systems",
            "It stores Wi-Fi keys",
            "It stores router ACLs",
            "It stores only encrypted zip archives",
            "It is a log file"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "On modern Unix/Linux systems, /etc/passwd stores user account information (username, UID, GID, home directory, shell) but not password hashes, which are moved to /etc/shadow for enhanced security (shadow password suite)."
        },
        {
          "question": "Which control most directly supports accountability in systems handling sensitive changes?",
          "options": [
            "Audit logs with user identity and timestamps",
            "Turning off authentication",
            "Anonymous shared accounts",
            "Removing approvals",
            "Disabling backups"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "Comprehensive audit logging that records who performed what action, when, and from where establishes accountability. This enables tracing actions to specific individuals, supporting investigations, compliance, and deterring malicious activity."
        },
        {
          "question": "Which of these is a typical secure practice for remote administrative access?",
          "options": [
            "Use SSH with strong authentication",
            "Use Telnet in plaintext",
            "Use shared root passwords",
            "Disable logging",
            "Use open Wi-Fi without encryption"
          ],
          "correctOption": 0,
          "points": 10,
          "explanation": "SSH (Secure Shell) with strong authentication (key-based, multi-factor) provides encrypted remote administration, protecting credentials and data from eavesdropping. Telnet sends credentials in plaintext and should never be used for administrative access."
        }
      ]
    }
  ]
}
